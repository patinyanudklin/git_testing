/* 
 *	filename IpcFile.h
 *		$Id: IpcFile.h,v 1.17 2014/12/07 03:03:57 rudahl Exp $	
 *
 *      ~~ Copyright 2001-2014 Kurt Rudahl and Sally Goldin
 *
 *	All rights are reserved. Copying or other reproduction of
 *	this program except for archival purposes is prohibited
 *	without the prior written consent of Goldin-Rudahl Associates.
 *
 *			  RESTRICTED RIGHTS LEGEND
 *
 *	Use, duplication, or disclosure by the U.S. Government
 *	is subject to restrictions as set forth in
 *	paragraph (b) (3) (B) of the Rights in Technical
 *	Data and Computer Software clause in DAR 7-104.9(a).
 *
 *	The moral right of the copyright holder is hereby asserted
 *	~~ EndC
 ****************************************************************
 * $Id: IpcFile.h,v 1.17 2014/12/07 03:03:57 rudahl Exp $
 * $Log: IpcFile.h,v $
 * Revision 1.17  2014/12/07 03:03:57  rudahl
 * undo most conditionals re STYLE
 *
 * Revision 1.16  2014/12/06 11:31:02  rudahl
 * conditional changes for OpenDragon
 *
 * Revision 1.15  2013/01/03 13:50:40  rudahl
 * added argument to specify ipc style (method)
 *
 * Revision 1.14  2008/09/27 11:43:50  rudahl
 * added waitReady
 *
 * Revision 1.13  2007/03/23 07:32:31  goldin
 * Fix syntax error
 *
 * Revision 1.12  2005/04/25 05:07:35  rudahl
 * added MsgTypeName, FileTypeName to IpcFile
 *
 * Revision 1.11  2005/02/12 02:58:02  goldin
 * Fixes to make this library compile
 *
 * Revision 1.10  2005/02/09 13:36:28  goldin
 * Update file comment block and includes in preparation for move to RSGISProject
 *
 * Revision 1.9  2002/02/20 16:01:20  rudahl
 * added optional second arg to clean()
 *
 * Revision 1.8  2001/08/15 13:49:27  rudahl
 * enriched sendCommand; added getSender, getSequence
 *
 * Revision 1.7  2001/06/15 19:52:29  rudahl
 * simplified IpcFile sendfile
 *
 * Revision 1.6  2001/05/30 17:28:47  rudahl
 * integrate server and viewport communication
 *
 * Revision 1.5  2001/05/09 20:59:43  rudahl
 * finished adapting for MSC16; started for Zortech* *.cpp *.h
 *
 * Revision 1.4  2001/05/08 20:26:29  rudahl
 * extensive revisions to support Viewport (16-bit), and to generally
 * advance the implementation stage.
 *
 * Revision 1.3  2001/05/02 18:40:03  rudahl
 * added Ipc writing capabilities, CLI args
 *
 * Revision 1.2  2001/04/29 18:02:05  rudahl
 * fixed problem retrieving command from cmd file
 *
 * Revision 1.1  2001/04/27 21:25:58  rudahl
 * Initial deposit from tower
 * This is the IPC package developed within Together
 *
 * Revision 1.1  2001/04/23 20:49:32  rudahl
 * initial deposit from Tower
 * Files somewhat generated by Together, modified by KTR
 * IpcFile mods based on Sally's Java implementation
 ****************************************************************
 * 
 * This is the header file for the IpcFile class.
 *
 ******************************************************************
 *	Developers
 * 		ktr	Kurt Rudahl
 *		seg	Sally Goldin
 *
 *	Revision History
 * 5.5	2005-2-9 ktr	imported from Dragon Academic Edition rev 5.4.4
 *	2005-4/25 ktr	added name strings for file and message types
 * 6.0	2008-09-27 ktr	added waitReady, for GCP
 * 6.3	2012-12-28 ktr	added IpcStyle
 */

#ifndef IPCFILE_H
#define IPCFILE_H

/**
 * This class represents an instance of a Dragon interprocess
 * communication (IPC) file. These files, which are of various types
 * and formats, are used to communicate between various Dragon modules
 * (UI, server, viewport, etc.). The present class encapsulates
 * some of the behaviors associated with these files, such as
 * checking if the file has been fully written, parsing the
 * file, and tracing the file detection.
 */

typedef enum
    {
    IPC_CLASSIC,
    IPC_XML,
    IPC_URL,
    IPC_SOCKET
    } IPC_STYLE_t;

#define IPC_STYLE_NAMES \
    "IPC_CLASSIC", \
    "IPC_XML", \
    "IPC_URL", \
    "IPC_SOCKET"

#ifdef __cplusplus

class DragonObject;
class Logger;

class IpcFile : public DragonObject
    {
    protected:
	/**
	 * The IPC file constructor is called after a file is known to
	 * exist, with a full name including path. It reads the file to
	 * determines if it is complete (based on file size). 
	 * If it is not complete, it leaves the bComplete flag set to false
  	 * and returns immediately. 
	 * The caller must repeatedly call isComplete() until successful.
	 * When the file is complete, isComplete or the constructor 
	 * does further processing, setting
	 * the various attributes of the file, reading the data, etc. 
	 * The detailed processing depends on the type of file involved. 
	 * @param filename    Name of IpcFile (with path). Since this file has 
	 *                    been detected in the file system,
	 *                    it is assumed to exist.
	 * @param uStyle      what type of IPC communication to use?
	 *		      IPC_XML wraps the content in XML
	 *		      IPC_URL and IPC_SOCKET yet to be defined
	 */
	IpcFile(const char * filename,IPC_STYLE_t uStyle = IPC_CLASSIC);	

    private:
	IpcFile() {};	

    public:	
	/* this is the method which checks whether a read file is
	 * completely read and processed. If necessary, it does
	 * the file processing
	 */
	BOOL isComplete();

	int getSizeInFile();
	time_t getTimeStamp();
	int getMsgCode();
	int getFileType();
	const char * getFileName();
	const char * getSourceModule();

	/* different types have different syntax of names.
	 * The subclass fns create a name (including path) valid for
	 * that subclass.
	 * *** THIS IS MALLOC'D - must be freed
	 * @param  czRemoteModule   the 2-letter abbreviation src/target
	 *                          '??' for wildcard
	 * @param  czSequence       '' for next avail, '*' for wildcard
	 */
	static char * createFilename(const char * czRemoteModule,
				     const char * czSequence);

	/* finish creating the file, and send it
	 * To use this, call the subclass with the file contents.
	 * The sublass will prefix that with other necessary fields
	 * and call this fn which will write it to the disk.
	 * @param   czName is without the path
	 * @param   czText is the trailing part of the contents.
	 * @param   czPrefix is prefixed to header before czText.
	 *          it may be "" but must not be NULL
	 * @param   pBlob if non-NULL is binary data to append
	 *          (prefixed by ^Z = 0x1A)
	 * @param   uBlobSize is size of binary data to append or 0
	 * @return  NULL if error; else the full text of the file
	 *          with ^Z replaced by \0 (this mem must be freed)
	 */
	static char * sendFile(const char * czName, const char * czText);

	static char * sendFile(const char * czName,const char * czText,
			       const char * czPrefix,
			       const byte * pBlob, const size_t uBlobSize);
	/* this one assumes node name is the full actual name
	 * just prefix the kpath
	 * *** THIS IS MALLOC'D - must be freed
	 */
	static const char * createFilename(const char * nodename);

	/** delete all files in kpath
	 */
	/** delete any IPC files which match pattern
	 *  @param czPattern 	OS-dependent wildcard pattern or NULL
	 *               	node-name only - no path or extension
	 *  @param czExtension  explicit extension or NULL
	 *			(if NULL, deletes $*)
	 */
	static void clean(const char * czPattern = NULL,
			  const char * czExtension = NULL);

	virtual const char * className();

	static const char * getFileTypeName(int uType)
	    { return s_czFiletypeNames[uType]; } ;
	static const char * getMsgTypeName(int uType)
	    { return s_czMsgtypeNames[uType]; } ;

	/* static function which uses much of parseHeader() to get
	 * the intended size and compare it to the actual size on the disk
	 * Once called this will block, so the caller should be sure
	 * that the desired file already exists
	 * @param fullFileName	path and name of desired file
	 */
	static void waitReady(const char * fullFileName);

	static const char * getIpcStyleName(IPC_STYLE_t uStyle);

    protected:
	/* this does the required Level 1 tracing
	* STATIC fn
	* NOMORE the file contents have '\r' replaced by ' ', '\n' by ';'
	* @param pczMessage gets modified by removing any trailing <cr><lf>
	*/
	static void doLevel1Tracing(const char * format,
				    const char * fileName,
				    char * pczMessage);
	void doError(const char * czMessage,const int iCode);

	/**
	 * Main method for reading the non-common parts of 
	 * the IPC file. This method must be implemented in subclasses.
	 */
	virtual void parseRemainder(char * buf)=0;

	/**
	 * Read the first line of the file and extract the
	 * timestamp and the size fields, which are common to
	 * all file types.
	 * Return the size recorded in the file. 
	 */
	int parseHeader(const char * fullFileName);

	/**
	 * Determine and return the fileType code, based on
	 * the file name. 
	 */
	int determineFileType(const char * fname);

	/**
	 * Factorization of main processing logic, allows
	 * both constructor and isComplete methods to access same
	 * code.
	 * @returns true if complete, else false. 
	 */
	BOOL processFile();

    protected: 	/* MEMBERS */

	/**
	 * Size of file as indicated in the file header. This is needed
	 * after the initial test by the progress file type, so that
	 * progress can be computed from file size. 
	 */
	int sizeInFile;

	/**
	 * Timestamp read from the file header 
	 */
	time_t timeStamp;

	/**
	 * Full filename of file (without path). Note that all IPC files 
	 * use 8+3 filename format. 
	 * 
	 */
	char czFileName[IPC_FILENAME_SZ+1];

	/**
	 * If true, file has been completely written. Otherwise, still 
	 * in the process. 
	 */
	BOOL bComplete;

	/**
	 * Code for module that generated this file 
	 */
	char czSourceModule[IPC_MODULEABBR_SZ+1];

	/**
	 * Type of file. One of the constants above. 
	 */
	int fileType;

	IPC_STYLE_t m_uStyle;

    private:
	static Class s_class_Base;
	static const char * s_czFiletypeNames[];
	static const char * s_czMsgtypeNames[];
    };

#endif // c++

#endif //IPCFILE_H

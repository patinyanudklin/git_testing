/* Ruler.java
 * kurt rudahl 10/26/2001
 * copyright goldin-rudahl associates
 * purpose: draw a ruler, or coordinate axis
 *****************************************************************************
 * $Id: Ruler.java,v 1.10 2002/09/05 01:00:51 rudahl Exp $
 * $Log: Ruler.java,v $
 * Revision 1.10  2002/09/05 01:00:51  rudahl
 * purge debug message
 *
 * Revision 1.9  2001/11/09 19:04:24  rudahl
 * improved tick binning; can omit ticks/labels
 *
 * Revision 1.8  2001/11/02 20:57:46  rudahl
 * refinements for viewport
 *
 * Revision 1.7  2001/11/01 09:57:54  rudahl
 * added GriddedPlaneSpace.java Makefile GriddedPlaneSpace.java
 *
 * Revision 1.6  2001/10/29 20:29:06  rudahl
 * refined calling params and documentation
 *
 * Revision 1.5  2001/10/29 15:27:03  rudahl
 * fixed main() implementation
 *
 * Revision 1.4  2001/10/29 13:17:41  rudahl
 *  fixed bugs in drawing fn params
 *
 * Revision 1.3  2001/10/27 19:20:26  rudahl
 * more improvements
 *
 * Revision 1.2  2001/10/27 17:32:37  rudahl
 * actually made it work, for Rulers
 *
 * Revision 1.1  2001/10/27 13:13:31  rudahl
 * initial despoit, from tower. Not yet working
 *
 *****************************************************************************
 * history 10/26/2001   created
 *                      Generated by Together
 */
package com.grs.metricCanvas;

import java.awt.*;

/**
 * draw a ruler, or coordinate axis
 */
public class Ruler extends LinearPlaneSpace
    {
      /** draw a ruler (coordinate axis). This does the whole
       *  operation; there are no other methods.
       *
       *  @param g           Graphics to draw into
       *  @param parent      enclosing Space, or null
       *  @param minRange    minimum value of variable which this ruler or
       *                     axis measures
       *  @param maxRange    maximum value of variable which this ruler or
       *                     axis measures
       *  @param logicalSize size, w.r.t. the parent or enclosing frame.
       *  @param offset      offset, w.r.t. the parent or enclosing frame.
       *                     If the parent or enclosing frame has its 
       *                     origin in the u.l. corner, 
       *                     offset.height should be negative.
       *  @param iDirection  0 => X 1 => Y
       *  @param iStyle      t.b.d.
       *  @param ticks       array of data values where ticks will be placed
       *			or null
       *  @param labels      array of labels corresponding to ticks
       *			or null
       *  @param dTickLength length of each tickmark, 
       *			as a fraction (0.0 to 1.0) of the logicalSize
       *			component orthogonal to the axis.
       */
    public Ruler(Graphics g, PlaneSpace parent, 
		 double minRange, double maxRange, 
		 Dimension logicalSize, Dimension offset,
		 int iDirection, int iStyle, double[] ticks, String[] labels,
		 double dTickLength) 
       throws DefectiveStructureException
        {
	super(g,parent,
	      (iDirection == X_AXIS) 
		 ? new double[]{minRange,0} : new double[]{0,minRange},
	      (iDirection == X_AXIS)
		 ? new double[]{maxRange,1} : new double[]{1,maxRange},
	      logicalSize,offset);
	/* for testing 
	g.setColor(Color.gray);
	fillBlock(minRange,maxRange);
	g.setColor(Color.yellow);
	*/
	if (iDirection == X_AXIS)
	    {
	      //	System.err.println("Ruler (en) doing X_AXIS");
	    double dTickBottom = 1.0 - dTickLength;
	    /* X-axis, so ticks are vertical & labels centered below */
	    if (ticks != null)
	        for (int i=0; i<ticks.length; i++)
		    {
		    if (i < labels.length) /* bulletproofing */
		        drawString(ticks[i],0.0,CENTER_JUSTIFIED,labels[i]);
		    /* don't draw zero-tick if no label */
		    if ((i > 0) || (labels[i].length() > 0))
		        drawLine(ticks[i],dTickBottom,ticks[i],1.0);
		    }
	    drawLine(new double[]{minRange,1.0},new double[]{maxRange,1.0});
	    }
	else
	    {
	    double dTickLeft = 1.0 - dTickLength;
	    /* Y-axis, so ticks are horizontal & labels centered left */
	    if (ticks != null)
	        for (int i=0; i<ticks.length; i++)
		    {
		    if (i < labels.length) /* bulletproofing */
		        drawString(dTickLeft - dTickLength/2,
				   ticks[i],RIGHT_CENTERED,labels[i]);
		    /* don't draw zero-tick if no label */
		    if ((i > 0) || (labels[i].length() > 0))
		        drawLine(dTickLeft,ticks[i],1.0,ticks[i]);
		    }
	    drawLine(new double[]{1.0,minRange},new double[]{1.0,maxRange});
	    }
	}

      /* create an array of values for locations of tick marks and labels
       * based on the known maximum value to be plotted, and whether
       * the data to be plotted is best understood as a base-10 or
       * base-2 value.
       * @param iMaxVal     the actual maximum value to be plotted
       * @param bBase2      if true, then the values will be powers of 2
       *		    if false, they will be in a biquinary sequence
       * @param iBinDensity How densly the bins are clustered 
       *		    This produces different results depending on
       *		    the maximum value as follows:
       *                     0 => In all cases only one bin (from 0 to max)
       *                     1 => for bBase2 or top value= 2 * 10 ^ n, 4 bins
       *                          for top value= 1 * 10 ^ n, 2 bins
       *                          for top value= 5 * 10 ^ n, 5 bins
       *                     2 => for bBase2 or top value= 2 * 10 ^ n, 4 bins
       *                          for top value= 1 * 10 ^ n, 5 bins
       *                          for top value= 5 * 10 ^ n, 5 bins
       * @return            an array of doubles which represent data 
       *                    positions for tick marks. 
       *                    The first element will be 0, 
       *                    the last will be a intended magnitude of the axis
       */
    public static double[] createAxisValues(int iMaxVal,boolean bBase2, 
					    int iBinDensity)
        {
	int i;
	int iMax = 0;
	int iMaxFactor = -1;
	int[] Top = (bBase2) ? s_i2MaxTop : s_iYMaxTop;
	for (i=0; i<Top.length; i++)
	    if (iMaxVal <= Top[i])
	        {
		iMax = Top[i];
		if (!bBase2)
		    iMaxFactor = i % 3; /* is it a 1, 2,or 5 multiple? */
		break;
		}
	int iAbins = 4;
	if (iBinDensity == 0)
	    iAbins = 1;
	else if (bBase2 || (iMaxFactor == 1))
	    iAbins = 4;
	else if (iMaxFactor == 0)
	    iAbins = (iBinDensity == 1) ? 2 : 5;
	else if (iMaxFactor == 2)
	    iAbins = 5;
	double[] AxisVals = new double[iAbins+1];
	for (i=0; i<AxisVals.length; i++)
	    {
	    int iVal = i * iMax / (AxisVals.length - 1);
	    AxisVals[i] = iVal;
	    //		yAxisLabels[i] = Integer.toString(iVal);
	    }
	return AxisVals;
	}

      /* create an array of labels for tick marks based on an array
       * of tick mark locations (e.g. created by Ruler.createAxisValues)
       * @param axisValues    array of values where tick marks will be placed
       * @param bIncludeZero  if true, include a label for point 0
       * @param iSkipFactor   if > 1 then only every 'iSkipFactor'-th label
       *		      will be other then ""
       * @return              an array of Strings which represent 
       *                      labels for the corresponding tick mark
       *                      The returned array will be the same length
       *                      as axisValues and will have a non-null string
       *                      for every entry.
       */
    public static String[] createAxisLabels(double[] axisValues,
					    boolean bIncludeZero,
					    int iSkipFactor)
        {
	String[] AxisLabels = new String[axisValues.length];
	for (int i=0; i<AxisLabels.length; i++)
	    {
	    int iVal = (int)axisValues[i];
	    if (i == 0)
	        AxisLabels[i] = (bIncludeZero) ? "0" : "";
	    else if ((iSkipFactor < 2) || ((i % iSkipFactor) == 0))
	        AxisLabels[i] = Integer.toString(iVal);
	    else
	        AxisLabels[i] = "";
	    }
	return AxisLabels;
	}

    public static final int X_AXIS = 0;
    public static final int Y_AXIS = 1;

      /* the following array is used to determine the top of the
       * Y-coordinate system in a 1,2,5 sequence */
    protected static final int s_iYMaxTop[]
       = { 10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,
	   100000,200000,500000,1000000,2000000,5000000,
	   10000000,20000000,50000000,100000000,200000000,500000000 };

      /* the following array is used to determine the max of the
       * coordinate system in a powers-of-2 sequence */
    protected static final int s_i2MaxTop[]
       = { 16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536 } ;



    public static Image OSC = null;
    public static Frame frame = null;

    public void paint(Graphics g)
        {
System.out.println("paint OSC="+OSC);
	if (OSC != null)
	    g.drawImage(OSC,0,0,frame);
	}
    public void update(Graphics g)
      {
	paint(g);
      }

    public static void main(String[] args)
        {
	frame = new Frame();
	frame.setBounds(new Rectangle(200,200,500,500));
	frame.setVisible(true);
	OSC = frame.createImage(200,200);
	if (OSC == null)
	    {
	    System.out.println("Unable to create image");
	    System.exit(1);
	    }
	Graphics g = OSC.getGraphics();
	Graphics gf = frame.getGraphics();
	try
	    {
	    g.setColor(Color.black);
	    g.fill3DRect(0,0,200,300,true);
	    g.setColor(Color.yellow);
	    Ruler r = new Ruler(g,null,0,100,
			    new Dimension(200,300),
			    new Dimension(0,0),X_AXIS,0,
			    new double[]{0.0,20.0,40.0,60.0,80.0,100.0},
			    new String[]{"0","","40","","80"},
			    0.40);
	    g.setColor(Color.blue);
	    g.fill3DRect(20,20,100,100,true);
	    g.setColor(Color.red);
	    g.drawString("treddy",50,50);
	    gf.drawImage(OSC,0,0,frame);
	    }
	catch(Exception e)
	  {
	    e.printStackTrace();
	  }
	}

    }

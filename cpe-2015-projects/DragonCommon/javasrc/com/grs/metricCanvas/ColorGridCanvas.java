/**
 * ColorGridCanvas
 *
 *  Copyright 2001 by Sally Goldin & Kurt Rudahl
 *
 *  Created by Sally Goldin, 11/2/2001
 *
 *  $Id: ColorGridCanvas.java,v 1.7 2005/02/06 08:21:59 goldin Exp $
 *  $Log: ColorGridCanvas.java,v $
 *  Revision 1.7  2005/02/06 08:21:59  goldin
 *  Fix javadoc warnings
 *
 *  Revision 1.6  2002/01/04 19:09:09  goldin
 *  Fix bugs in color mapping
 *
 *  Revision 1.5  2001/11/15 18:09:16  goldin
 *  Add function to support mouse motion listener
 *
 *  Revision 1.4  2001/11/12 16:04:40  goldin
 *  Modifications to support color chooser
 *
 *  Revision 1.3  2001/11/09 15:19:11  goldin
 *  Added code to set individual colors
 *
 *  Revision 1.2  2001/11/05 15:46:52  goldin
 *  Added mouse sensitivity to ColorGridCanvas, fixed calculation bugs
 *
 *  Revision 1.1  2001/11/02 19:13:59  goldin
 *  Working on color grid implementation
 *
 */
package com.grs.metricCanvas;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;

/** 
 * This class extends Canvas. It encapsulates a ColorGrid object
 * and a BufferedImage object.
 * When its rpaint() method is called, the class redraws the color
 * grid. The color array must be set separately via a setColors
 * method.
 */
public class ColorGridCanvas extends Canvas 
                             implements MouseListener
    {
      // Row and column indices corresponding to last mouse click
    protected int iLastRowClicked = -1;
    protected int iLastColClicked = -1;
      // Modifiers associated with last mouse click
    protected int iLastModifiers = 0;

      /**
       * This class holds a reference to a ColorGrid object,
       * which is created by its constructor.
       */
    protected ColorGrid colorGrid = null;

      /**
       * This class also holds a reference to an image where
       * the ColorGrid will be drawn.
       */
    protected BufferedImage gridImage = null;

      /**
       * Graphics associated with the image.
       */
    protected Graphics2D imageG = null;

    protected Dimension prefSize = null;

      /**
       * If true, colors should be assigned in column major
       * rather than row major order.
       */
    protected boolean bColumnMajor = false;

      /**
       * Hold on to # rows and columns
       */
    protected int m_iNRows = -1;
    protected int m_iNCols = -1;

      /**
       * Constructor takes the dimension parameters of the
       * the colorGrid.
       */
    public ColorGridCanvas(int iNRows, int iNCols,
                     int iCellWidth, int iCellHeight, 
		     int iXGutterSize, int iYGutterSize)
        { 
        prefSize = new Dimension((iNCols*iCellWidth),
				 (iNRows*iCellHeight));
        gridImage = new BufferedImage(prefSize.width,
				      prefSize.height,
				      BufferedImage.TYPE_INT_RGB);
        imageG = gridImage.createGraphics();
        colorGrid = new ColorGrid(imageG,iNRows, iNCols,
                                  iCellWidth, iCellHeight, 
				  iXGutterSize, iYGutterSize);
	m_iNRows = iNRows;
	m_iNCols = iNCols;
	setSize(prefSize);
        addMouseListener(this);
        }        

    public Dimension getPreferredSize()
        {
	return prefSize;
	}

    /**
     *  Set the current set of Grid colors and replot the
     *  grid on the image. 
     *  This call is simply delegated to the 
     *  ColorGrid object.
     */
    public void setGridColors(Color dataArray[])
        {
	Color newArray[] = null;
        if (bColumnMajor)
            newArray = reorderColors(dataArray);
        else
	    newArray = dataArray;
	try 
	    {
            colorGrid.plot(newArray);
	    }
        catch (DefectiveStructureException dse)
	    {
            dse.printStackTrace();
	    }
	}

      /**
       * Factorization. Take an array of colors, assumed to
       * be in row major order (i.e. row 0, col 0, row 0, col1, etc.)
       * and return a new array in column major order (row 0, col0, row 1,
       * col 0, etc.).
       * @param inputColors  Array of colors to be reordered
       * @return color array where row varies faster than column.
       */
    protected Color[] reorderColors(Color inputColors[])
        {
        int row = -1;
	int col = 0;
	int index = 0;
        int rowsPerCol = inputColors.length/m_iNCols;
        if (rowsPerCol > m_iNRows)
            rowsPerCol = m_iNRows;
        Color result[] = new Color[inputColors.length];
        // start by copying the array so all will be initialized
	// then overwrite by reordering
	System.arraycopy(inputColors,0,result,0,inputColors.length);
        for (int i = 0; i < inputColors.length; i++)
	    {
            row += 1;
	    if (row == rowsPerCol)
	        {
		row = 0;
		col+= 1;
		}
	    if (col >= m_iNCols)
	        break;
	    index = row * m_iNCols + col;
	    //System.out.println("i=" + i + " calculated row=" +
	    //   row + " col=" + col + " index=" + index +
	    //   " color=" + inputColors[i]);
	    result[index] = inputColors[i];
	    }
	return result;
	}

    /**
     * Change a single color in color table.
     * based on its index. This simply delegates to the
     * encapsulated ColorGrid object.
     * @param index  Row whose cell should be set.
     * @param newColor  New color 
     */
    public void setOneColor(int index, Color newColor)
        {
        if (bColumnMajor)
	    {
	    int col = index / m_iNRows;
	    int row = index % m_iNRows;
	    int newIndex = row * m_iNCols + col;
            colorGrid.setOneColor(newIndex, newColor);
            }
	else
            colorGrid.setOneColor(index, newColor);
        }
    
    /**
     * Request that the color grid redraw itself.
     */
    public void replotColors()
        {
        try
	   {
	   colorGrid.replot();
	   }
	catch (DefectiveStructureException e)
	   {
	   e.printStackTrace();
	   }
	}

    /**
     * Get a color based on its index
     */
   public Color getOneColor(int index)
       {
       return colorGrid.getOneColor(index);
       }

    /**
     *  redraw the data on the canvas.
     */
    public void paint(Graphics g)
        {
	  // System.out.println("Paint in ColorGridCanvas called");
	g.drawImage(gridImage,0,0,this);
	}

    public void update(Graphics g)
        {
	  // System.out.println("Update in ColorGridCanvas called");
	paint(g);
	}

    /**
     * Mouse Listener methods 
     */
    public void mouseClicked(MouseEvent e)
        {
        }

    public void mouseEntered(MouseEvent e)
        {
        }

    public void mouseExited(MouseEvent e)
        {
        }

    public void mousePressed(MouseEvent e)
        {
	  //System.out.println("Mouse coordinates are: " + e.getX() +
	  //		   ", " + e.getY());
        Point p = colorGrid.getGridCell(e.getX(), e.getY());
        iLastRowClicked = p.y;
	iLastColClicked = p.x;
        iLastModifiers = e.getModifiers();
        //System.out.println("Clicked on cell " + iLastRowClicked + ", " +
	//		   iLastColClicked + "(linear index "+
	//		   getLastCellClicked() + ")");
        }

    public void mouseReleased(MouseEvent e)
        {
        }
      
    public int getLastModifiers()
        {
	return iLastModifiers;
	}

      /**
       * Returns the linear index of last cell clicked.
       */
    public int getLastCellClicked()
        {
	if ((iLastRowClicked < 0) || (iLastColClicked < 0))
	    return -1;
        if (bColumnMajor)
            return (iLastColClicked * m_iNRows) + iLastRowClicked;
        else 
	    return (iLastRowClicked * m_iNCols) + iLastColClicked; 
        }

      /**
       * Returns index associated with a mouse event.
       * Used to implement mouse motion tracking.
       */
    public int getMouseIndex(MouseEvent e)
        {
        Point p = colorGrid.getGridCell(e.getX(), e.getY());
        int iRow = p.y;
	int iCol = p.x;
        if ((iRow < 0) || (iCol < 0))
            return -1; 
        if (bColumnMajor)
            return (iCol * m_iNRows) + iRow;
        else 
	    return (iRow * m_iNCols) + iCol; 
        }


      /**
       * Set column major flag
       */
    public void setColumnMajor(boolean flag)
        {
        bColumnMajor = flag;
	}

    /** TEST DRIVER **/
    public static void main(String[] args)
        {
	Frame frame = new Frame();
	frame.setBounds(new Rectangle(200,200,500,500));
        frame.setLayout(new BorderLayout());
	ColorGridCanvas cgc = new ColorGridCanvas(43,6,10,10,2,2);
        Color BasicColors[] = new Color[256];
        for (int iColor = 0; iColor < 256; iColor++)
	    {
	    BasicColors[iColor] = new Color(BasicMap[iColor*3],
			 BasicMap[iColor*3 + 1],
			 BasicMap[iColor*3 + 2]);
	    }
        cgc.setGridColors(BasicColors);
        Panel p = new Panel(new BorderLayout());
        p.add(cgc,BorderLayout.CENTER);
	frame.add(new Label("Dummy"), BorderLayout.WEST);
	frame.add(p, BorderLayout.CENTER);
	frame.setVisible(true);
	}

    public static final int BasicMap[] = {
      0x0,0x0,0x0, 0x0,0x0,0x30, 0x0,0x0,0x60, 0x0,0x0,0x90, 
      0x0,0x0,0xC0, 0x0,0x0,0xF0, 0x0,0x30,0x0, 0x0,0x30,0x30, 
      0x0,0x30,0x60, 0x0,0x30,0x90, 0x0,0x30,0xC0, 0x0,0x30,0xF0, 
      0x0,0x60,0x0, 0x0,0x60,0x30, 0x0,0x60,0x60, 0x0,0x60,0x90, 
      0x0,0x60,0xC0, 0x0,0x60,0xF0, 0x0,0x90,0x0, 0x0,0x90,0x30, 
      0x0,0x90,0x60, 0x0,0x90,0x90, 0x0,0x90,0xC0, 0x0,0x90,0xF0, 
      0x0,0xC0,0x0, 0x0,0xC0,0x30, 0x0,0xC0,0x60, 0x0,0xC0,0x90, 
      0x0,0xC0,0xC0, 0x0,0xC0,0xF0, 0x0,0xF0,0x0, 0x0,0xF0,0x30, 
      0x0,0xF0,0x60, 0x0,0xF0,0x90, 0x0,0xF0,0xC0, 0x0,0xF0,0xF0, 
      0x30,0x0,0x0, 0x30,0x0,0x30, 0x30,0x0,0x60, 0x30,0x0,0x90, 
      0x30,0x0,0xC0, 0x30,0x0,0xF0, 0x30,0x30,0x0, 0x30,0x30,0x30, 
      0x30,0x30,0x60, 0x30,0x30,0x90, 0x30,0x30,0xC0, 0x30,0x30,0xF0, 
      0x30,0x60,0x0, 0x30,0x60,0x30, 0x30,0x60,0x60, 0x30,0x60,0x90, 
      0x30,0x60,0xC0, 0x30,0x60,0xF0, 0x30,0x90,0x0, 0x30,0x90,0x30, 
      0x30,0x90,0x60, 0x30,0x90,0x90, 0x30,0x90,0xC0, 0x30,0x90,0xF0, 
      0x30,0xC0,0x0, 0x30,0xC0,0x30, 0x30,0xC0,0x60, 0x30,0xC0,0x90, 
      0x30,0xC0,0xC0, 0x30,0xC0,0xF0, 0x30,0xF0,0x0, 0x30,0xF0,0x30, 
      0x30,0xF0,0x60, 0x30,0xF0,0x90, 0x30,0xF0,0xC0, 0x30,0xF0,0xF0, 
      0x60,0x0,0x0, 0x60,0x0,0x30, 0x60,0x0,0x60, 0x60,0x0,0x90, 
      0x60,0x0,0xC0, 0x60,0x0,0xF0, 0x60,0x30,0x0, 0x60,0x30,0x30, 
      0x60,0x30,0x60, 0x60,0x30,0x90, 0x60,0x30,0xC0, 0x60,0x30,0xF0, 
      0x60,0x60,0x0, 0x60,0x60,0x30, 0x60,0x60,0x60, 0x60,0x60,0x90, 
      0x60,0x60,0xC0, 0x60,0x60,0xF0, 0x60,0x90,0x0, 0x60,0x90,0x30, 
      0x60,0x90,0x60, 0x60,0x90,0x90, 0x60,0x90,0xC0, 0x60,0x90,0xF0, 
      0x60,0xC0,0x0, 0x60,0xC0,0x30, 0x60,0xC0,0x60, 0x60,0xC0,0x90, 
      0x60,0xC0,0xC0, 0x60,0xC0,0xF0, 0x60,0xF0,0x0, 0x60,0xF0,0x30, 
      0x60,0xF0,0x60, 0x60,0xF0,0x90, 0x60,0xF0,0xC0, 0x60,0xF0,0xF0, 
      0x90,0x0,0x0, 0x90,0x0,0x30, 0x90,0x0,0x60, 0x90,0x0,0x90, 
      0x90,0x0,0xC0, 0x90,0x0,0xF0, 0x90,0x30,0x0, 0x90,0x30,0x30, 
      0x90,0x30,0x60, 0x90,0x30,0x90, 0x90,0x30,0xC0, 0x90,0x30,0xF0, 
      0x90,0x60,0x0, 0x90,0x60,0x30, 0x90,0x60,0x60, 0x90,0x60,0x90, 
      0x90,0x60,0xC0, 0x90,0x60,0xF0, 0x90,0x90,0x0, 0x90,0x90,0x30, 
      0x90,0x90,0x60, 0x90,0x90,0x90, 0x90,0x90,0xC0, 0x90,0x90,0xF0, 
      0x90,0xC0,0x0, 0x90,0xC0,0x30, 0x90,0xC0,0x60, 0x90,0xC0,0x90, 
      0x90,0xC0,0xC0, 0x90,0xC0,0xF0, 0x90,0xF0,0x0, 0x90,0xF0,0x30, 
      0x90,0xF0,0x60, 0x90,0xF0,0x90, 0x90,0xF0,0xC0, 0x90,0xF0,0xF0, 
      0xC0,0x0,0x0, 0xC0,0x0,0x30, 0xC0,0x0,0x60, 0xC0,0x0,0x90, 
      0xC0,0x0,0xC0, 0xC0,0x0,0xF0, 0xC0,0x30,0x0, 0xC0,0x30,0x30, 
      0xC0,0x30,0x60, 0xC0,0x30,0x90, 0xC0,0x30,0xC0, 0xC0,0x30,0xF0, 
      0xC0,0x60,0x0, 0xC0,0x60,0x30, 0xC0,0x60,0x60, 0xC0,0x60,0x90, 
      0xC0,0x60,0xC0, 0xC0,0x60,0xF0, 0xC0,0x90,0x0, 0xC0,0x90,0x30, 
      0xC0,0x90,0x60, 0xC0,0x90,0x90, 0xC0,0x90,0xC0, 0xC0,0x90,0xF0, 
      0xC0,0xC0,0x0, 0xC0,0xC0,0x30, 0xC0,0xC0,0x60, 0xC0,0xC0,0x90, 
      0xBC,0xBC,0xBC, 0xC0,0xC0,0xF0, 0xC0,0xF0,0x0, 0xC0,0xF0,0x30, 
      0xC0,0xF0,0x60, 0xC0,0xF0,0x90, 0xC0,0xF0,0xC0, 0xC0,0xF0,0xF0, 
      0xF0,0x0,0x0, 0xF0,0x0,0x30, 0xF0,0x0,0x60, 0xF0,0x0,0x90, 
      0xF0,0x0,0xC0, 0xF0,0x0,0xF0, 0xF0,0x30,0x0, 0xF0,0x30,0x30, 
      0xF0,0x30,0x60, 0xF0,0x30,0x90, 0xF0,0x30,0xC0, 0xF0,0x30,0xF0, 
      0xF0,0x60,0x0, 0xF0,0x60,0x30, 0xF0,0x60,0x60, 0xF0,0x60,0x90, 
      0xF0,0x60,0xC0, 0xF0,0x60,0xF0, 0xF0,0x90,0x0, 0xF0,0x90,0x30, 
      0xF0,0x90,0x60, 0xF0,0x90,0x90, 0xF0,0x90,0xC0, 0xF0,0x90,0xF0, 
      0xF0,0xC0,0x0, 0xF0,0xC0,0x30, 0xF0,0xC0,0x60, 0xF0,0xC0,0x90, 
      0xF0,0xC0,0xC0, 0xF0,0xC0,0xF0, 0xF0,0xF0,0x0, 0xF0,0xF0,0x30, 
      0xF0,0xF0,0x60, 0xF0,0xF0,0x90, 0xF0,0xF0,0xC0, 0xEC,0xEC,0xEC, 
      0x4,0x4,0x4, 0x8,0x8,0x8, 0xC,0xC,0xC, 0x14,0x14,0x14, 
      0x18,0x18,0x18, 0x1C,0x1C,0x1C, 0x24,0x24,0x24, 0x28,0x28,0x28, 
      0x2C,0x2C,0x2C, 0x34,0x34,0x34, 0x38,0x38,0x38, 0x3C,0x3C,0x3C, 
      0x44,0x44,0x44, 0x48,0x48,0x48, 0x4C,0x4C,0x4C, 0x54,0x54,0x54, 
      0x58,0x58,0x58, 0x5C,0x5C,0x5C, 0x64,0x64,0x64, 0x68,0x68,0x68, 
      0x6C,0x6C,0x6C, 0x74,0x74,0x74, 0x78,0x78,0x78, 0x7C,0x7C,0x7C, 
      0x84,0x84,0x84, 0x88,0x88,0x88, 0x8C,0x8C,0x8C, 0x94,0x94,0x94, 
      0x98,0x98,0x98, 0x9C,0x9C,0x9C, 0xA4,0xA4,0xA4, 0xAC,0xAC,0xAC, 
      0xB4,0xB4,0xB4, 0xC4,0xC4,0xC4, 0xCC,0xCC,0xCC, 0xD4,0xD4,0xD4, 
      0xDC,0xDC,0xDC, 0xE4,0xE4,0xE4, 0xF4,0xF4,0xF4, 0xFC,0xFC,0xFC };

    }

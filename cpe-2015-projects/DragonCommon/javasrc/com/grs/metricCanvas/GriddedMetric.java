/* GriddedMetric.java
 * kurt rudahl 10/26/2001
 * copyright goldin-rudahl associates
 * purpose: Force points to snap to a grid
 **************************************************************************
 * $Id: GriddedMetric.java,v 1.6 2001/11/05 15:46:52 goldin Exp $
 * $Log: GriddedMetric.java,v $
 * Revision 1.6  2001/11/05 15:46:52  goldin
 * Added mouse sensitivity to ColorGridCanvas, fixed calculation bugs
 *
 * Revision 1.5  2001/11/02 19:13:59  goldin
 * Working on color grid implementation
 *
 * Revision 1.4  2001/11/01 09:57:19  rudahl
 * revised ctor
 *
 * Revision 1.3  2001/10/27 17:40:06  rudahl
 * added ctor
 *
 * Revision 1.2  2001/10/27 17:32:37  rudahl
 * actually made it work, for Rulers
 *
 * Revision 1.1  2001/10/27 13:13:31  rudahl
 * initial despoit, from tower. Not yet working
 *
 **************************************************************************
 * history 10/26/2001   created
 *                      Generated by Together
 */

package com.grs.metricCanvas;

/**
 * Force points to snap to a (linear) grid
 * The output values are grid cell identifiers, possibly with an offset
 * The input values are data values.
 */
public class GriddedMetric implements Metric
    {
      /** specify how many grid INTERVALS
       */
    GriddedMetric(int iSteps)
        {
	m_MinInput = 0.0;
	m_MaxInput = 0.0;
	m_iMinOutput = m_iMaxOutput = 0;
	m_iSteps = iSteps;
	m_StepSize = 1.0;
	m_iOutStepSize = 1;
	}

     GriddedMetric(double minInput, double maxInput, 
		   int minOutput, int maxOutput,
		   int iSteps)
        {
	this(iSteps);
        //System.out.println("maxInput = " + maxInput + " maxOutput = " 
	//	   + maxOutput + " nSteps=" + iSteps);
        setRange(minInput,maxInput,minOutput,maxOutput);
	}

      /** specify the minimum to maximum possible coordinate values
       *  (closed interval; min < max)
       */
    public void setRange(double minInput, double maxInput, 
			 int iMinOutput, int iMaxOutput)
        {
	m_MinInput = minInput;
	m_MaxInput = maxInput;
	m_iMinOutput = iMinOutput;
	m_iMaxOutput = iMaxOutput;
	m_StepSize = (1.0 + maxInput - minInput) / m_iSteps;
	m_iOutStepSize = (1 + iMaxOutput - iMinOutput) / m_iSteps;
        if (m_iOutStepSize < 1)
            m_iOutStepSize = 1;
	}

      /** remap the specified 1-dimensional point to conform to
       *  this metric. 
       */
    public int remap(double point)
        {
	int iStepNo = (int)((point - m_MinInput + 0.5)/ m_StepSize);
	int iRetval = iStepNo * m_iOutStepSize + m_iMinOutput;
	return iRetval;
	}

      /** reverse the mapping. Given an output point, map to
       * input values.
       */
    public double unmap(int iPoint)
        {
        double retval = (double)(iPoint - m_iMinOutput) *  
                        (m_StepSize / (double) m_iOutStepSize) + m_MinInput;
        return retval;
        }

      /**
       * synonyms that make the direction of mapping clearer
       * and also test/clip their input
       */

      /**
       * Returns grid cell associated with point, or
       * -1 if outside the grid.
       */
    public int dataToGrid(double point)
        {
        if ((point > m_MaxInput) || (point < m_MinInput))
	    {
	      //System.out.println("Out of range point " + point +
	      //		       "(Min-Max is " + m_MinInput + "-" +
	      //		       m_MaxInput + ")");
            return -1;
	    }
	else 
            return remap(point);
	}

    public double gridToData(int iPoint)
        {
        if (iPoint < m_iMinOutput)
            iPoint = m_iMinOutput;
        if (iPoint > m_iMaxOutput)
            iPoint = m_iMaxOutput;
        return unmap(iPoint);
	}

    public double getStepSize()
        {
        return m_StepSize;
	}
    
    protected double m_MinInput; 
    protected double m_MaxInput;
    protected int m_iMinOutput;
    protected int m_iMaxOutput;
    protected double m_StepSize;
    protected int m_iOutStepSize;
    protected int m_iSteps;
    }

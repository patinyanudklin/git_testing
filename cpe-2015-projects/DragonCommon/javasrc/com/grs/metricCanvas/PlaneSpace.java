/* PlaneSpace.java
 * kurt rudahl 10/26/2001
 * copyright Sally Goldin & Kurt Rudahl
 * purpose:  A two-dimensional version of a Space 
 *
 *****************************************************************************
 * $Id: PlaneSpace.java,v 1.7 2005/02/06 08:21:59 goldin Exp $
 * $Log: PlaneSpace.java,v $
 * Revision 1.7  2005/02/06 08:21:59  goldin
 * Fix javadoc warnings
 *
 * Revision 1.6  2002/06/10 19:30:03  goldin
 * Make all rects at least 1 pixel wide
 *
 * Revision 1.5  2001/11/02 19:13:59  goldin
 * Working on color grid implementation
 *
 * Revision 1.4  2001/10/29 13:17:41  rudahl
 *  fixed bugs in drawing fn params
 *
 * Revision 1.3  2001/10/27 19:20:26  rudahl
 * more improvements
 *
 * Revision 1.2  2001/10/27 17:32:37  rudahl
 * actually made it work, for Rulers
 *
 * Revision 1.1  2001/10/27 13:13:31  rudahl
 * initial despoit, from tower. Not yet working
 *
 *****************************************************************************
 * history 10/26/2001   created
 *                      Generated by Together
 */

package com.grs.metricCanvas;

import java.awt.*;

public abstract class PlaneSpace extends Space
    {
      /** create a PlaneSpace within another PlaneSpace, or by itself
       *  If within another Planespace, then all public drawing commands
       *  may be specified in either local (the remap fns are applied)
       *  or parent terms
       *  @param g         Graphics object for drawing into
       *  @param parent    enclosing PlaneSpace, or null
       *                   if null, remapping uses scaling factors = 1  
       *  @param offset    offset in pixels from parent or other reference.
       *                   In case of ambiguity, the reference point is
       *                   the lower-left corner.
       */
    PlaneSpace(Graphics g, PlaneSpace parent, Metric[] metric,
               double[] minRange, double[] maxRange, 
	       Dimension logicalRange, Dimension offset) 
        {
	super(parent,2,metric,minRange,maxRange,
	      intArray(logicalRange),intArray(offset));
	m_g = g;
	//System.err.println(
	//"PlaneSpace ctor logRange="+logicalRange.width+","+logicalRange.height
	//	   +" offset="+offset.width+","+offset.height);
	}

	/*
    void PlaneSpace(Graphics g, int iXmin, int iYmin, int iXmax, int iYmax)
        {
	m_g = g;
	m_iXmin = iXmin;
	m_iYmin = iYmin;
	m_iXmax = iXmax;
	m_iYmax = iYmax;
	}

    void setDimensions(int iXmin, int iYmin, int iXmax, int iYmax)
        {
	m_iXmin = iXmin;
	m_iYmin = iYmin;
	m_iXmax = iXmax;
	m_iYmax = iYmax;
	}
	*/

    Dimension remap(Dimension dim)
       throws DefectiveStructureException
        {
	double[] f = new double[2];
	f[0] = dim.width;
	f[1] = dim.height; /* Space requires X,Y,... order */
	int[] i = remap(f);
	return new Dimension(i[0],i[1]);
	}

      /** convert a Dimension to an int[] correct for Space
       */
    protected static int[] intArray(Dimension d)
        {
	return new int[]{d.width,d.height};
	}

      /*
    abstract Rectangle remap(Rectangle rect);

    abstract int remapX(int iX);

    abstract int remapY(int iY);

    abstract Dimension remap(int iX, int iY);
    */

    public void drawLine(double x0, double y0, double x1, double y1)
       throws DefectiveStructureException
        {
	drawLine(new double[]{x0,y0},new double[]{x1,y1});
	}

    public void drawLine(double[] start, double[] end)
       throws DefectiveStructureException
        {
	int[] iSt = remap(start);
	int[] iEnd = remap(end);
	//System.err.println("PlaneSpace drawing line from "+iSt[0]+","+iSt[1]+" to "+iEnd[0]+","+iEnd[1]);
	//	m_g.drawLine(iSt[0],m_LogicalPixels[1]-iSt[1],iEnd[0],m_LogicalPixels[1]-iEnd[1]);
	m_g.drawLine(iSt[0],-iSt[1],iEnd[0],-iEnd[1]);
	}

      /** draw a right rectangular n-dimensional thing
       * @param corner0   the corner with the lowest value in each dimension
       * @param corner1   the corner with the highest value in each dimension
       */
    public void drawBlock(double[] corner0, double[] corner1)
       throws DefectiveStructureException
        {
	int[] iLL = remap(corner0);
	int[] iUR = remap(corner1);
	/* note - see fillblock */
	m_g.drawRect(iLL[0],-iUR[1],iUR[0]-iLL[0],(iUR[1]-iLL[1]));
	}

      /** draw and fill a right rectangular n-dimensional thing
       * @param corner0   the corner with the lowest value in each dimension
       * @param corner1   the corner with the highest value in each dimension
       */
    public void fillBlock(double[] corner0, double[] corner1)
       throws DefectiveStructureException
        {
	int[] iLL = remap(corner0);
	int[] iUR = remap(corner1);
	int width = iUR[0] - iLL[0];
	if (width == 0) 
	    width = 1;
        int height = iUR[1]-iLL[1];
	if (height == 0)
	    height = 1;
	//System.err.println("fillblock corner at "+iLL[0]+","+(-iLL[1])+" size="+(iUR[0]-iLL[0])+","+(iUR[1]-iLL[1]));
	/* note - use iUR[1] for second arg because of the reversed directionality of 'y' in Graphics */
	m_g.fillRect(iLL[0],-iUR[1],width,height);
	}

      /** draw and fill a right circular thing
       * @param center    the center
       * @param iDiameter  diameter is expressed in logicalPixels
       */
    public void fillCircle(double[] center, int iDiameter)
       throws DefectiveStructureException
        {
	int[] iC = remap(center);
	m_g.fillOval(iC[0],-iC[1],iDiameter,iDiameter);
	}

      /** draw specified string using current font
       *  @param x   X coord of reference point of text placement
       *  @param y   Y coord of reference point of text placement
       *  @param iPlacement placement of text w.r.t. position
       *  @param str        text to be rendered
       */
    public void drawString(double x, double y, int iPlacement, String str)
       throws DefectiveStructureException
        {
	drawString(new double[]{x,y},iPlacement,str);
	}

    public void drawString(double[] position, int iPlacement, String str)
       throws DefectiveStructureException
        {
	    // System.err.println("About to draw string at "+position[0]+","+position[1]);
	if ((str != null) && (str.length() > 0))
	    {
	    int[] iPos = remap(position);
	    FontMetrics fm = m_g.getFontMetrics();
	    int iWidth = fm.stringWidth(str);
	    int iHeight = fm.getHeight() - fm.getDescent();
	    if (iPlacement == CENTERED)
	        {
		iPos[0] -= iWidth / 2;
		iPos[1] -= iHeight / 2;
		}
	    else if (iPlacement == RIGHT_CENTERED)
	        {
		iPos[0] -= iWidth;
		iPos[1] -= iHeight / 2;
		}
	    else if (iPlacement == CENTER_JUSTIFIED)
	        iPos[0] -= iWidth / 2;
	    else if (iPlacement == RIGHT_JUSTIFIED)
	        iPos[0] -= iWidth;
	    //System.err.println("Drawing string "+str+" at "+iPos[0]+","+(-iPos[1]));
	    //	    m_g.drawString(str,iPos[0],m_LogicalPixels[1]-iPos[1]);
	    m_g.drawString(str,iPos[0],-iPos[1]);
	    }
	}

    protected Graphics m_g = null;

      /* additional values for iPlacement of string in 2D */
    public static final int RIGHT_CENTERED = 4; /* centered vertically */

    }

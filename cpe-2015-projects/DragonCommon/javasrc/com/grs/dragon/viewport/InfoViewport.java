/****************************************************************
 *
 *          InfoViewport.java - replaces viewport 0
 *			 K.T. Rudahl
 *
 *          Copyright 2001-2002 by Sally Goldin & Kurt Rudahl
 *
 ***************************************************************
 * $Id: InfoViewport.java,v 1.29.2.2 2012/03/02 05:44:46 rudahl Exp $
 * $Log: InfoViewport.java,v $
 * Revision 1.29.2.2  2012/03/02 05:44:46  rudahl
 * fixed to repaint when needed
 *
 * Revision 1.29.2.1  2010/09/11 11:28:02  rudahl
 * adapt for java 1.6
 *
 * Revision 1.29  2007/05/13 08:07:06  goldin
 * Make histograms and other infoviewports repaint when resized
 *
 * Revision 1.28  2007/03/22 12:08:50  goldin
 * Get rid of I18N string in MEA graphs - temporary fix
 *
 * Revision 1.27  2007/02/10 08:22:12  goldin
 * Improve cycling of infoviewports
 *
 * Revision 1.26  2005/11/22 03:24:11  goldin
 * Update to be consistent with 5.6 - use frame for histograms and scatterplots so they'll have icons
 *
 * Revision 1.26  2005/08/14 07:14:22  goldin
 * Modify to make InfoViewport a top-level window rather than a dialog
 *
 * Revision 1.25  2005/02/06 09:17:30  goldin
 * Fix javadoc warnings
 *
 * Revision 1.24  2002/10/24 18:21:47  goldin
 * Stagger infoviewport positions
 *
 * Revision 1.23  2002/09/14 17:41:30  rudahl
 * improved scales on SCA
 *
 * Revision 1.22  2002/09/05 15:57:09  rudahl
 * fixup title I18N
 *
 * Revision 1.21  2002/06/10 19:31:03  goldin
 * Add a bit to the origin so histogram bar at zero will show up
 *
 * Revision 1.20  2002/04/16 20:04:07  rudahl
 *  minor cleanup
 *
 * Revision 1.19  2002/04/03 22:01:11  goldin
 * Add freq.key to SCA
 *
 * Revision 1.18  2002/04/03 18:01:02  goldin
 * Add index to InfoViewport so that maybe someday we can distinguish them
 *
 * Revision 1.17  2002/02/22 16:44:26  goldin
 * Fix algorithm for positioning signature graphs
 *
 * Revision 1.16  2002/02/19 20:57:56  goldin
 * Display
 *
 * Revision 1.15  2002/02/05 17:33:12  goldin
 * Fix graphing problems
 *
 * Revision 1.14  2002/01/15 19:29:31  rudahl
 * fixes to infoviewport
 *
 * Revision 1.13  2002/01/10 22:32:02  rudahl
 * improving infoviewport
 *
 * Revision 1.12  2001/11/28 17:08:30  rudahl
 * added processing of Fn-key presses
 *
 * Revision 1.11  2001/11/19 15:23:35  rudahl
 * convert to Graphics2D
 *
 * Revision 1.10  2001/11/16 16:37:47  goldin
 * Begin moving UI code to other packages as relevant
 *
 * Revision 1.9  2001/11/15 20:46:41  rudahl
 * moved viewport java files to their own package
 *
 * Revision 1.8  2001/11/09 19:02:05  rudahl
 * fixed some graphing problems
 *
 * Revision 1.7  2001/11/08 21:59:27  rudahl
 *  improvements in infoviewport
 *
 * Revision 1.6  2001/11/07 18:48:50  rudahl
 * add support for changing button labels, for MEA
 *
 * Revision 1.5  2001/11/05 20:28:49  rudahl
 * adapt to dragon.ui package *.java
 *
 * Revision 1.4  2001/11/05 17:20:43  rudahl
 * now have C/EDI/HIS working
 *
 * Revision 1.3  2001/11/02 21:00:35  rudahl
 * further advances on U/HIS & U/SCA
 *
 * Revision 1.2  2001/11/01 18:10:28  rudahl
 * added initial implementation of infoViewport
 *
 * Revision 1.1  2001/09/24 18:11:05  rudahl
 * added JniDialog as base class, and improved or added its subclasses
 *
 *************************************************************************
 * history 10/24/2001   created
 *                      Generated by Together
 */
package com.grs.dragon.viewport;

import java.util.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.border.*;
import com.grs.metricCanvas.*;
import com.grs.util.*;
import com.grs.gui.*;

public class InfoViewport extends JniFrame implements ActionListener, ComponentListener
    {
    protected boolean m_bFinished = false; /* set true by OK */
    protected JPanel displayArea = null;
    protected Dimension bpSize;
    protected int index = -1;  // appends a sequence # to title 
    protected Date lastDisplayedTime = null;

      /* clear out local data before a new plot 
       */
    public void reinit()
        {
	m_bFinished = false; /* set true by OK */
	}

    public void actionPerformed(ActionEvent e)
        {
	killDialog();
	m_bFinished = true;
	}

    public InfoViewport() { super(null); }

      /** construct an InfoViewport
       *  @param   viewMsgs     keyed set of translated messages
       *  @param   vpSize       Dimension of window to create
       *  @param   index        Index into array. Used to append
       *                         sequence # to title
       */
    public InfoViewport(I18NTextSource viewMsgs,Dimension vpSize,
			int index)
        {
	super(viewMsgs,"InfoView??");
	viewProg.logViewport("InfoViewport ctor");
        setSize(vpSize);
	this.index = index;
	addComponentListener(this);

	JButton button = new JButton(viewMsgs.getI18NText("%h1E.0","OK"));
	button.setActionCommand("OK");
	button.addActionListener(this);
	JPanel buttonPanel = new JPanel();
	buttonPanel.setBorder(new EmptyBorder(10,10,10,10));
	buttonPanel.add(button);
	Container cp = getContentPane();
	displayArea = new JPanel();
	cp.setLayout(new BorderLayout());
	cp.add(displayArea, BorderLayout.CENTER);
        cp.add(buttonPanel, BorderLayout.SOUTH);
	bpSize = buttonPanel.getPreferredSize();

	//	setMinSize(new Dimension(350,300));
	//	m_buttonSize = button.getPreferredSize();
	setKeyEventsToViewport(new String[]{    "F1","F2","F3","F4","F5",
						"F6","F7","F8","F9","F10"});
	setKeyEventsToDismiss(new String[]{"F1","F10"}); /* these also exit */
	viewProg.logViewport("InfoViewport::ctor (ex)");
	}

    public BufferedImage OSC = null;

      /* count number of lines starting with 'X='
       * Return at first line of any other type which follows
       * at least one X= line
       * @param infoData   vector of info lines
       * @param iFirstLine index of infoData to start with
       * @return           count of X= lines found 
       */
    protected int countPoints(Vector infoData, int iFirstLine)
        {
	int iPointCount = 0;
	int iInfoSize = infoData.size();
	/* loop counting data points (lines starting with X=) */ 
	for (int iInfoIndex = iFirstLine; iInfoIndex < iInfoSize; iInfoIndex++)
	    {
	    String infoLine = (String)infoData.elementAt(iInfoIndex);
	    if (infoLine == null)
		break;
	    if(infoLine.startsWith("X="))
		iPointCount++;
	    else if(iPointCount > 0)
		break;
	    }
	return iPointCount;
	}

      /* extract 1 dataset's worth of data
       * @param infoData   vector of info lines
       * @param iFirstLine index of infoData to start with
       * @param x,y        array to be filled with x,y-values
       * @param color      null, or array to be filled with color values
       * @return           index of last line processed
       */
    protected int collectPointData(Vector infoData, int iFirstLine,
				   Hashtable fields,
				   double[] x, double[] y, Color[] color)
       throws IOException, Exception
        {
	int iPointIndex = 0;
	int iInfoIndex;
	int iInfoSize = infoData.size();
	for (iInfoIndex = iFirstLine; iInfoIndex < iInfoSize; iInfoIndex++)
	    {
	    String infoLine = (String)infoData.elementAt(iInfoIndex);
	    if (infoLine == null)
		break;
	    viewProg.logViewport("InfoViewport::collect infoLine="+infoLine);
	    if(infoLine.startsWith("( "))
	        continue;
	    fields = Parse.getParamNameValues(infoLine," ",fields);
	    /*
	      Enumeration en = fields.keys();
	      String enlist = "";
	      while (en.hasMoreElements())
	      {
	      String key = (String)en.nextElement();
	      enlist += key+"='"+(String)fields.get(key)+"' ";
	      }
	      viewProg.logViewport("enlist="+enlist);
	      */
	    if(infoLine.startsWith("X="))
	        {
		x[iPointIndex]
		  = Double.valueOf((String)fields.get("X")).doubleValue();
		y[iPointIndex]
		  = Double.valueOf((String)fields.get("Y")).doubleValue();
		if (color != null)
		    {
		    int iColnum = Integer.parseInt((String)fields.get("Z"));
		    //iColnum is actually a slice # from 0 - 7
		    color[iPointIndex] = s_ScaColors[iColnum];
		    }
		//viewProg.logViewport("InfoViewport::setup point "
		//	     +iPointCount+" of "+x.length
		//	     +" ="+x[iPointCount]+","+y[iPointCount]);
		iPointIndex++;
		}
	    else if(iPointIndex > 0)
		break;
	    }
	return iInfoIndex;
	}

      /** set contents
       *  @param   jsOp         name of operation whose results are being
       *			displayed
       *  @param   jsTitle	initial title to display (DO NOT apply i18n)
       *  @param   jsInfoFile	full path to file containing parameters
       *			defining the data to be displayed.
       *                   	The appearance of the display is specific to
       *                      	each jsOp.
       *			File format (for SCA):
       *			   ( comment )
       *			   Title1="X-axis title string" ( or Title2= )
       *			   MaxX=n MaxY=n MaxZ=n AxisMagnfiy=n
       *			      ( only MaxX and MaxY currently used )
       *			   X=n Y=n Z=n  ( plot dot in color Z )
       *  @param   parentArea   screen coords occupied by parent VP,
       *                        or all zeroes
       */
    public void setupContents(String jsOp, String jsTitle, 
			      String jsInfoFile,
			      Rectangle parentArea)
       throws IOException, Exception
        {
	viewProg.logViewport("InfoViewport::setup (en) op="+jsOp);
	OSC = null;
	Vector infoData = Smallfile.rsf(jsInfoFile,"UTF-8");
	//	int iInfoSize = infoData.size();
	int iGraphType = PlotGraph.LINE;
	int iMaxYFactor = -1; // -1=>power-of-two; 0=>10^n 1=>2x10^n 2=>5x10^n 
	int iOp = -1;
        String jsTitle1 = null;
	String jsTitle2 = null;
	String tempTitle = null;
	/* divide avail space into how many subwindows? */
	int iXSubWindows = 1;
	int iYSubWindows = 1;
	if (jsOp.equals("U/SCA"))
	    iOp = UScaOp;
	else if (jsOp.equals("U/HIS"))
	    iOp = UHisOp;
	else if (jsOp.equals("C/EDI/HIS"))
	    iOp = CHisOp;
	else if (jsOp.equals("G/MEA/HIS"))
	    iOp = GHisOp;
	else if (jsOp.equals("G/MEA/PRO"))
	    iOp = GProOp;

	if (iOp == UScaOp)
	    {
	    iGraphType = PlotGraph.POINT;
	    tempTitle = "SCA " + String.valueOf(index);
	    }
	else if ((iOp == UHisOp) || (iOp == CHisOp) || (iOp == GHisOp))
	    {
	    iGraphType = PlotGraph.BAR_FILLED;
	    tempTitle = "HIS " + String.valueOf(index);
	    }
	else if (iOp == GProOp)
	    {
	    iGraphType = PlotGraph.LINE;
	    tempTitle = "PRO " + String.valueOf(index);
	    }

	//if (jsTitle.trim().length() > 0)
	//   setTitle(jsTitle);
	//else 
        setTitle(tempTitle);
	Graphics2D g = null;

	/* if C/EDI/HIS, there are mult. data sets; else only 1 (at present)
	 */
	int iInfoIndex = 0;
	int iDataSetCount = 0;
	int iDataSetFirst = 0; /* the first is the largest */
	int iInfoLastLine = infoData.size() - 1;
	while (iInfoIndex < iInfoLastLine)
	    {
	    /* count data points (lines starting with X=) */ 
	    int iPointCount = countPoints(infoData,iInfoIndex);
	    
	    /* parse and collect the data */
	    Hashtable fields = new Hashtable();
	    double[] x = new double[iPointCount];
	    double[] y = new double[iPointCount];
	    Color[] color = null; /* for SCA */
	    if (iOp == UScaOp)
	        color = new Color[iPointCount];
	    iInfoIndex 
	      = collectPointData(infoData,iInfoIndex,fields,x,y,color);
	    viewProg.logViewport("Looping over datasets: iIndex="+iInfoIndex
				 +" iLastLine="+iInfoLastLine
				 +" dataset#="+iDataSetCount);
	    String fldList = "";
	    Enumeration en = fields.keys();
	    while (en.hasMoreElements())
	      {
		Object key = en.nextElement();
		fldList += "'"+(String)key+"'='"+(String)fields.get(key)+"'; ";
	      }
	    viewProg.logViewport("    fldList="+fldList);
	    /* calculate some coord axis sizes and labels */
	    double[] xAxisVals = null;
	    double[] yAxisVals = null;
	    int iMaxX = 256; /* default */
	    int iMaxY = 256;
	    if (fields.containsKey("MaxX"))
	        {
		String v = (String)fields.get("MaxX");
		iMaxX = Integer.parseInt(v);
		}
	    if (fields.containsKey("MaxY"))
	        {
		String v = (String)fields.get("MaxY");
		iMaxY = Integer.parseInt(v);
		}

	    jsTitle1 = (fields.containsKey("Title1"))
		  ? (String)fields.get("Title1") : "";
	    jsTitle2 = (fields.containsKey("Title2"))
		  ? (String)fields.get("Title2") : "";
	    int iDataSet = (fields.containsKey("DataSet"))
		  ? Integer.parseInt((String)fields.get("DataSet")) : 0;
	    // ~~~ The following lines were intended to assure that in SCA, 
	    // if the two max values were only slightly different 
	    // e.g. 120 & 130, the
	    // resulting presentation would use the same scale on both axes.
	    // However this produced undesirable results when they were
	    // VERY different e.g. one image is classified. Temp. disabled.
	    if ((iOp == UScaOp) && (iMaxX != iMaxY)
		   && (iMaxX * 2 > iMaxY) && (iMaxY * 2 > iMaxX))
	        iMaxX = iMaxY = (iMaxX > iMaxY) ? iMaxX : iMaxY; 
	    if (iOp == UScaOp)
	        yAxisVals = Ruler.createAxisValues(iMaxY,true,1);
	    else
	        yAxisVals = Ruler.createAxisValues(iMaxY,false,1);
	    xAxisVals = Ruler.createAxisValues(iMaxX,true,4);
	    viewProg.logViewport("Creating X-axis bins based on iMaxX="+iMaxX
			     +"; calculated Axis size="
			     +(int)xAxisVals[xAxisVals.length-1]);
	    iMaxX = (int)xAxisVals[xAxisVals.length-1];
	    iMaxY = (int)yAxisVals[yAxisVals.length-1];
	    String[] yAxisLabels = Ruler.createAxisLabels(yAxisVals,false,1);
	    String[] xAxisLabels = Ruler.createAxisLabels(xAxisVals,false,1);
	    if (OSC == null)
	        {
		iDataSetFirst = iDataSet; /* save hishtest num */
		iXSubWindows = (2 + iDataSet) / 2;
		iYSubWindows = (iXSubWindows + iDataSet) / iXSubWindows;
		  /* set total size of display area, based on number of
		   * datasets which need to be displayed */
                // NOT actually doing this
		OSC = new BufferedImage(getWidth()-20,
					getHeight()-bpSize.height,
					BufferedImage.TYPE_INT_RGB);
		viewProg.logViewport(
		    "Image created with size " + OSC.getWidth() + ", " +
		     OSC.getHeight());
		if (OSC == null)
		    throw new Exception("Unable to create image");
		}
	    g = OSC.createGraphics();
	    if (g == null)
	        throw new Exception("Unable to create Graphics");
	    HashMap renderMap = new HashMap();
	    renderMap.put(RenderingHints.KEY_ANTIALIASING,
			  RenderingHints.VALUE_ANTIALIAS_ON);
	    renderMap.put(RenderingHints.KEY_RENDERING,
			  RenderingHints.VALUE_RENDER_QUALITY);

	    g.setRenderingHints(new RenderingHints(renderMap));
	    g.setFont(new Font("Lucida Sans Unicode",Font.BOLD,14));
	    /* location of plot portion of graph w.r.t OSC l.l.corner */
	    FontMetrics fm = g.getFontMetrics();
	    int iMaxYLabelLen = yAxisLabels[yAxisLabels.length-1].length();
	    int iMargin = 15;      /* unused space on all sides */
	    int iXRulerHt = fm.getHeight() + 5;
	    int iYRulerWd = fm.charWidth('0')*iMaxYLabelLen + 15;
	    int iPlotXOrigin = iMargin + iYRulerWd;
	    int iPlotYOrigin = iMargin + iXRulerHt;
	    viewProg.logViewport("Initial Origin="+iPlotXOrigin+","
                                  +iPlotYOrigin);
	    int iPlotWidth = OSC.getWidth(this)/iXSubWindows;
	    int iPlotHeight = OSC.getHeight(this)/iYSubWindows; 
	    // assuming row major layout, row (multiplier for graph bottom)
	    // is dataset number divided by #cols, i.e. iXSubWindows,
	    // while column (multiplier for graph left) is 
	    // dataset number mod the #cols.
	    int iGraphBottom = iPlotHeight  
	    	  	    * (1 + (int)(iDataSet/iXSubWindows));
	    int iGraphLeft = iPlotWidth  
		  		* (int)(iDataSet % iXSubWindows);
	    iPlotWidth -= (iPlotXOrigin + (2*iMargin));
	    iPlotHeight -= (iPlotYOrigin + (2*iMargin + 40));
            if (iOp == UHisOp)
                iPlotHeight -= 30;
	    iPlotXOrigin += iGraphLeft;
	    iPlotYOrigin = iGraphBottom - iPlotYOrigin;
	    if (iOp == UScaOp) /* leave room for Horiz axis title */
		iPlotYOrigin -= 20;
	    viewProg.logViewport("drawRegion for DataSet "+iDataSet
				 +": Origin="+iPlotXOrigin+","+iPlotYOrigin
				 +"; Size="+iPlotWidth+","+iPlotHeight);
	    viewProg.logViewport("iXSubWindows="+iXSubWindows
				 +" iYSubWindows="+iYSubWindows);
	    try
	        {
		int iTestHt = OSC.getHeight(this)/iYSubWindows;
		int iTestWd = OSC.getWidth(this)/iXSubWindows;
		g.setColor(Color.black);
		int iGraphTop = (OSC.getHeight(this)/iYSubWindows)
		  		* (int)(iDataSet/iXSubWindows);
		g.fillRect(1+iGraphLeft,1+iGraphTop,
			   iTestWd-5,iTestHt-2);
		g.setColor(Color.yellow);

		Ruler rx 
		  = new Ruler(g,null,0,iMaxX,
			      new Dimension(iPlotWidth,iXRulerHt),
			      new Dimension(iPlotXOrigin,
					       -iPlotYOrigin-iXRulerHt),
			      Ruler.X_AXIS,0,
			      (iOp == GProOp) ? null : xAxisVals,
			      (iOp == GProOp) ? null : xAxisLabels,
			      0.30);
		Ruler ry 
		  = new Ruler(g,null,0,iMaxY,
			      new Dimension(iYRulerWd,iPlotHeight),
			      new Dimension(iPlotXOrigin-iYRulerWd,
						-iPlotYOrigin),
			      Ruler.Y_AXIS,0,
			      yAxisVals,
			      yAxisLabels,
			      (double)iMaxYLabelLen/(double)(10*fm.charWidth('0')));
		}
	    catch(Exception e)
	        {
		e.printStackTrace();
		}
	    int iPlotYOffset = -iPlotYOrigin;
	    viewProg.logViewport("InfoViewport::setup iMaxY="+iMaxY
			     +" Plot size="+iPlotWidth+","+iPlotHeight
			     +" Origin="+iPlotXOrigin+","+iPlotYOffset);
	    PlotGraph graph 
	      = new PlotGraph(g,null,new double[]{0,0},
	      		      new double[]{iMaxX,iMaxY},
			      new Dimension(iPlotWidth,iPlotHeight),
			      new Dimension(iPlotXOrigin+2,
					    -iPlotYOrigin+1),
			      iGraphType);
	    try
	        {
		/* iYSizeBand[0] is the height of a single band display */
		int iGraphTop = (OSC.getHeight(this)/iYSubWindows)
		  		* (int)(iDataSet/iXSubWindows);
		g.setColor(Color.green);
		if (iOp == UScaOp)
		    {
		    graph.setGlyphSize(4); // 5);
		    graph.plot(x,y,color);
		    drawScaKey(g,iPlotWidth - 50, iGraphTop + 50);
		    }
		else
		    graph.plot(x,y);
		g.setColor(Color.yellow);
		viewProg.logViewport("InfoViewport::setupContents"  +
                                 " iGraphTop=" +
                                 iGraphTop + " iPlotXOrigin=" +
                                 iPlotXOrigin);
		if (iOp == CHisOp)
		   jsTitle1 += " B"+(iDataSet+1);
                /* ~~~ Temporary fix for I18N Problem in canvas 3/22/07 */ 
                else if ((iOp ==  GProOp) || 
                         (iOp ==  GHisOp))
                    {
		    /*find the last blank - the figure number follows */
		    char c[] = jsTitle1.toCharArray();
		    int pos = c.length - 1;
                    while ((c[pos] != ' ') && (pos >= 0))
                        {
			pos--;
                        }  
                    jsTitle1 = "# " + jsTitle1.substring(pos+1);
                    }
 
		if (iOp == UScaOp) /* assuming title1 is Horiz axis */
		    g.drawString(jsTitle1,
				 iPlotXOrigin + iPlotWidth/4,
				 iPlotYOrigin + 50);
		else
		    {
		    g.drawString(jsTitle1,
				 iPlotXOrigin+10,iGraphTop+60);
		    }
		if ((jsTitle2 != null) && (iOp == UScaOp))
	            g.drawString(jsTitle2,iPlotXOrigin+10,iGraphTop+60);
		else if ((iOp == UHisOp) && (jsTitle2 != null) &&
			(jsTitle2.length() > 0))
	            g.drawString(jsTitle2,iPlotXOrigin+10,iGraphTop+80);
		}
	    catch (Exception e)
	        {
		e.printStackTrace();
		}
	    }
	repaint();
	if (g != null)
	    g.dispose();
	//if (gf != null)
	//   gf.dispose();
	setLocation((iOp == GProOp) ? 3 : 1,parentArea);
		/* to the left of parent; Profile offset a bit */
	}

    public void paint(Graphics g)
        {
	super.paint(g);
	if (OSC != null)
	    {
	    g.drawImage(OSC,0,0,
			OSC.getWidth(displayArea),
			OSC.getHeight(displayArea),
			Color.black,displayArea);
	    }
	}

      /**
       * Draw a vertical color bar showing the lowest to highest
       * frequency colors used in the scatter plot.
       * @param g  Graphics to use for drawing
       * @param x  Upper left X for key bar
       * @param y  Upper left y for key bar.
       */
    protected void drawScaKey(Graphics g, int x, int y)
        {
	viewProg.logViewport("drawScaKey at " + x + "," + y);
	Color saveColor = g.getColor();
	int width = 20;
	int height = 10;
	for (int i = (s_ScaColors.length - 1); i > 0; i--)
	    {
	    g.setColor(s_ScaColors[i]);
	    g.fillRect(x,y,width,height);
	    y += height;
	    }
	g.setColor(saveColor);
	}
       
    protected static final Color[] s_ScaColors
	= { Color.black, Color.blue, Color.green, Color.cyan,
	    Color.red, Color.magenta, Color.yellow, Color.white
	  } ;

      /** 
       *  Set the location of the dialog; override the JniDialog
       *  method to add a staircasing based on the value of index.
       *  
       *  @param   iStrategy    specify placement strategy:
       *                         0 => centered; ignore parent
       *                         1 => by preference, to the side of the parent
       *                         2 => by preference below the parent
       *                         3 => like 1, but offset (staircased) a bit
       *  @param   parentArea   screen coords occupied by parent VP,
       *                        or all zeroes
       */
    public void setLocation(int iStrategy,
			    Rectangle parentArea)
        {
        super.setLocation(iStrategy, parentArea);
	Point currentLoc = getLocation();
	if (index > 0)
	    {
            currentLoc.x += (index * 30);
	    currentLoc.y += (index * 20);
	    setLocation(currentLoc);
	    }
        }


    protected static final int UScaOp = 0;
    protected static final int UHisOp = 1;
    protected static final int CHisOp = 2;
    protected static final int GHisOp = 3;
    protected static final int GProOp = 4;

    public int getIndex()
        {
	return index;
	}

    public Date getLastDisplayedTime()
        {
	return lastDisplayedTime;
	}

    public void setLastDisplayedTime(Date now)
	{
	lastDisplayedTime = now;
	}

      /** display the dialog - Override parent method
       * to explicitly call paint.
       * Copied from Dragon Professional code 28 Feb 2012
       */
    public void showIt()
        {
	setVisible(true);
	Graphics g = this.getGraphics();
	paint(g);
        FramePopper popper = new FramePopper(this);
	javax.swing.Timer myTimer = new javax.swing.Timer(2000,popper);
	myTimer.setRepeats(false);
        myTimer.start();
	}



    /* ComponentListener methods */
    public void componentHidden(ComponentEvent e)
        {
        }

    public void componentMoved(ComponentEvent e)
        {
        }

    public void componentResized(ComponentEvent e)
        {
	repaint();       
        }

    public void componentShown(ComponentEvent e)
        {
	repaint();
        }


    /** Inner class to pop the InfoViewport to the front.
     * Copied from Dragon Professional code base 28 Feb 2012
     */
    class FramePopper implements ActionListener
    {
        JFrame frame = null;

        public FramePopper(JFrame thisFrame)
	{
	    frame = thisFrame;
	}
        
	public void actionPerformed(ActionEvent ev)
	{
	    frame.toFront();
	} 
    }



    public static void main(String[] args)
        {
	try
	    {
	    I18NTextSource i18nMessages = new I18NTextSource("EN/view.msg");
	    InfoViewport vp = new InfoViewport(i18nMessages,
					       new Dimension(500,500),0);
	    InfoViewport vp2 = new InfoViewport(i18nMessages,
					       new Dimension(500,500),1);
	    System.out.println("Infoviewport");
	    Rectangle parent = new Rectangle(0,0,0,0);
	    vp.setupContents("U/HIS","optitle","H:/tmp/dragtmp/DATV0999.$$$",
			     parent);
	    //vp2.setupContents("U/SCA","optitle",
	    //                     "H:/tmp/dragtmp/DATV0990.$$$",parent);
	    }
	catch (Exception e)
	    {
	    System.out.println("exception "+e.getMessage());
	    e.printStackTrace();
	    }
	}
    }



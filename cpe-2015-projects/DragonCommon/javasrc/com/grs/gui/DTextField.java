/* DTextField.java
 *
 * Generated by java-pp.pl from DTextField.java
 * on Mon Jan  8 11:41:07 EST 2001
 
 * Copyright  2001-2007  by Sally Goldin & Kurt Rudahl
 *
 * $Id: DTextField.java,v 1.9 2007/01/05 07:41:57 rudahl Exp $
 * $Log: DTextField.java,v $
 * Revision 1.9  2007/01/05 07:41:57  rudahl
 * added Whatis info
 *
 * Revision 1.8  2005/02/06 08:08:11  goldin
 * Fix JavaDoc warnings
 *
 * Revision 1.7  2002/09/23 23:00:38  goldin
 * Make beep part of error display  rather than a reaction in the control
 *
 * Revision 1.6  2002/09/23 19:11:44  goldin
 * Infrastructure to suppress file validation when file chooser is coming up
 *
 * Revision 1.5  2002/05/29 17:54:01  goldin
 * Add support for returning blanks
 *
 * Revision 1.4  2002/04/29 22:36:16  goldin
 * Fine tune error message delivery
 *
 * Revision 1.3  2002/04/17 00:54:16  goldin
 * Fix problem with dual error msg display when clicking on OK
 *
 * Revision 1.2  2002/01/18 16:29:03  goldin
 * increase focus request time delay
 *
 * Revision 1.1  2001/11/30 18:03:09  goldin
 * Moved most of the UI basic components to the com.grs.gui package
 *
 * Revision 1.26  2001/11/05 13:59:15  goldin
 * Put UI code in a package
 *
 * Revision 1.25  2001/10/17 10:29:36  goldin
 * Modify to use ApplicationManager to get error display, etc.
 *
 * Revision 1.24  2001/10/03 15:15:46  goldin
 * Modify display to index some lines
 *
 * Revision 1.23  2001/06/25 15:01:31  goldin
 * Fix problem with non-firing of ImageENableCallback
 *
 * Revision 1.22  2001/06/19 10:40:07  goldin
 * Fix validation/focusloss loop bug
 *
 * Revision 1.21  2001/06/18 12:10:00  goldin
 * Fixing bugs found by Kurt
 *
 * Revision 1.20  2001/05/16 15:43:31  goldin
 * Fine tune control appearance and behavior
 *
 * Revision 1.19  2001/05/10 13:14:51  goldin
 * Continue implementation of SigFile and scaling callbacks
 *
 * Revision 1.18  2001/05/07 14:21:15  goldin
 * Modify focus lost to always call validator
 *
 * Revision 1.17  2001/04/25 15:36:50  goldin
 * began implementation of command line
 *
 * Revision 1.16  2001/04/25 12:18:32  goldin
 * Fix bug wrt border redraw; set focus to first control
 *
 * Revision 1.15  2001/04/24 14:14:20  goldin
 * Improve behavior and appearance of file and font choosers
 *
 * Revision 1.14  2001/04/18 15:32:45  goldin
 * Added home directory command line argument
 *
 * Revision 1.13  2001/04/10 11:18:46  goldin
 * Fix problem with modal dialog in FileValidator; extend IntegerValidator
 *
 * Revision 1.12  2001/03/23 16:28:59  goldin
 * Make Timer package explicit
 *
 * Revision 1.11  2001/03/22 12:57:33  goldin
 * Implement paths panel, including initializer, callback, new path datatype
 *
 * Revision 1.10  2001/03/20 13:33:02  goldin
 * Disable all fields after OK
 *
 * Revision 1.9  2001/03/16 19:23:46  goldin
 * Added fixed length option for DTextField and DFileField; added callbacks to menu items
 *
 * Revision 1.8  2001/03/02 19:56:21  goldin
 * Add horizontal label option for DTextFields, add handling of translated help msgs
 *
 * Revision 1.7  2001/02/28 16:24:29  goldin
 * implementing defaults, enhancements to help editor
 *
 * Revision 1.6  2001/01/25 20:16:19  goldin
 * Continued work on layout and XML parsing
 *
 * Revision 1.5  2001/01/17 14:18:23  goldin
 * Actually build initial trial panel from XML document
 *
 * Revision 1.4  2001/01/15 14:20:25  goldin
 * Implement new layout options, makeClone methods
 *
 * Revision 1.3  2001/01/12 19:10:21  goldin
 * Completed implementation of basic control types, added validation and callback support, key handling
 *
 * Revision 1.2  2001/01/09 15:58:55  goldin
 * continued work implementing basic appearance of UI components
 *
 * Revision 1.1  2001/01/08 19:34:42  goldin
 * Initial population for new DRAGON-Java UI
 *
 */

package com.grs.gui;
import java.util.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


/** Control used in response panels to allow the user to enter
*   text strings.
* @author  goldin
* @version  Mon Jan 08 11:36:01 EST 2001*/
public class DTextField extends DragonField 
                        implements FocusListener
    {
    static protected String BLANKSTRING = "   ";

      /**
       * If true, label should be laid out horizontally
       * on the same line as the field itself.
       */
    protected boolean bHorizontal = false;

      /** Width in character columns for the text field.
       */
    protected int displayWidth = 20;
    
      /** Control that implements the actual text entry
       *   part of the field.
       */
    protected JTextField inputField;
    
    protected JPanel innerPanel = null;
    protected JPanel outerPanel = null;

      /**
       * Limit to the number of characters allowed in the
       * field. If no limit, this value will be -1
       */
    protected int maxInputChars = -1;

      /**
       * If true, user just asked to see choice dialog. So, don't
       * validate a partial data entry - this may be used as a 
       * filter pattern.
       */
    protected boolean bInChoiceDialog = false;
      
      /**
       * Set to true if blank values should be returned
       */
    protected boolean bReturnBlanks = false;

    //********************************************************************
      /**
       * Constructor, needed in order to be able
       * to have a different constructor for DFileField, which
       * does its own layout. The DFileField constructor explicitly
       * calls this constructor. THIS CONSTRUCTOR SHOULD NOT BE
       * USED BY ANYONE ELSE.
       * @param name  Name for the new field.
       */
    public DTextField(String name)
        {
	this.name = name;
	bTextControl = true;
	}

      /**
       * Constructor: creates field and label and arranges them.
       * @param name  Name for new field
       * @param text  Text for label; if null, no label created
       * @param columns Number of columns to display for the text field.
       * @param bHorizontal If true, label should be to the left of the
       *                    field, not on top.
       */
    public DTextField(String name, String text, int columns,
                      boolean bHorizontal)
        {
 	this.name = name;
        this.bHorizontal = bHorizontal;
	this.labelText = text;
	setLayout(new BorderLayout());
	innerPanel = new JPanel(new BorderLayout(5,0));
	outerPanel = new JPanel(new BorderLayout());
	if (text != null)
	    {
	    label = new JLabel(text);
	    if (bHorizontal)
	        innerPanel.add(label,BorderLayout.WEST);
	    else
	        innerPanel.add(label,BorderLayout.NORTH);
	    }
	if (columns > 0)
	    displayWidth = columns;
	inputField = new JTextField(displayWidth);
        inputField.setDocument(new FixedLengthDocument(maxInputChars));
	inputField.addFocusListener(this);
	inputField.addKeyListener(this);
        if (bHorizontal)
	    innerPanel.add(inputField,BorderLayout.EAST);
	else
	    innerPanel.add(inputField,BorderLayout.SOUTH);
	outerPanel.add(innerPanel,BorderLayout.NORTH);
	add(outerPanel,BorderLayout.WEST);
        bTextControl = true;
	}

    //********************************************************************
      /**
       * Create and return copy of the present object. Data items
       * that are set during the addition to a panel are not 
       * copied.
       */
    public DragonField makeClone()
        {
	DTextField clone = new DTextField(name,label.getText(),
					  displayWidth, bHorizontal);
	initializeClone(clone);
        clone.setMaxInputChars(maxInputChars);
        clone.setReturnBlanks(bReturnBlanks);

	return (DragonField) clone;
	}

    //********************************************************************
      /** Tries to set the focus to the control associated
       *  with the field. Since each field subclass has different
       *  controls, this method must be implemented for each one.
       */
    public void requestFocus()
        {
	inputField.requestFocus();
	}
    
    //********************************************************************
      /** Returns the current value for the field. Must be overridden
       *   by each subclass.
       */
    public String getFieldValue() 
        {
	String curValue = inputField.getText();
        if ((bReturnBlanks) && (curValue.length() == 0))
             return BLANKSTRING;
	else
   	     return inputField.getText();
        }

    //********************************************************************
      /** Sets the field to be enabled or disabled depending
       *   on the value of the bEnabled argument.
       *   
       * @param  bEnabled Enablement flag
       */
    public void setEnabled(boolean bEnabled) 
        {
	this.bEnabled = bEnabled;
	if (label != null)
	    {
	    label.setEnabled(bEnabled);
	    }
	inputField.setEnabled(bEnabled);
	if (!bEnabled)
	    {
            inputField.setText("");
	    }
        }
    
    //********************************************************************
      /** Allows the panel or other outside class to set the value of the
       *   field. Must be overridden in each subclass,
       * @param  value String to use to set value of the control.
       *   This may need to be transformed to
       *   an index or some other form.
       */
    public void setFieldValue(String value) 
        {
	inputField.setText(value);
        }

      /** Calculates the minimum amount of space (in pixels) required
       * by the field's graphic components. This will usually be
       * based on things like the width of the label in the current font.
       * @return Minimum width of graphical components, in pixels.
       */
    public int calculateWidth()
        {
	int labelWidth = 0;
	int controlWidth = 0;
	if (label != null)
	    {
	    FontMetrics metrics = label.getFontMetrics(label.getFont());
	    labelWidth = metrics.stringWidth(label.getText());
	    }
	controlWidth = inputField.getPreferredSize().width;
        if (bHorizontal)
            return labelWidth + controlWidth + 5;
	else
	    return Math.max(labelWidth,controlWidth);
	}

      /** Calculates the minimum amount of vertical space (in pixels) required
       * by the field's graphic components. This will usually be
       * based on things like the width of the label in the current font.
       * @return Minimum height of graphical components, in pixels.
       */
    public int calculateHeight()
        {
	int controlHeight = 0;
	int labelHeight = 0;
        if (!bHorizontal)
	    {
	    if (label != null)
	        {
		FontMetrics metrics = label.getFontMetrics(label.getFont());
		labelHeight = metrics.getHeight() + 
		    metrics.getMaxDescent();
		}
	    }
	controlHeight = inputField.getPreferredSize().height;
        return labelHeight + controlHeight + 5;
	}

      /**
       * Returns true if passed control is equivalent to present
       * control - that is, all values are the same.
       */
    public boolean equivalent(DragonField field)
        {
	if (!(field instanceof DTextField))
	    return false;
	if (!commonFieldsEqual(field))
	    return false;
	DTextField tField = (DTextField) field;
	if (tField.getDisplayWidth() != displayWidth)
	    return false;
	return true;
	}


      /**
       * Method to clear the field - if this is relevant.
       * Most control types use the base class method, which
       * does nothing, but here, we override it.
       */
    public void clearField()
        {
	inputField.setText("");
        previousValue=null;
        setUserData(null);
	}
    
    //********************************************************************
      /**
       * Methods from FocusListener interface, responds to gain or
       * loss of focus.
       */
    public void focusLost(FocusEvent e)
        {
        boolean bDialogVisible = false;
        boolean bCommandLine = (this.getName().compareTo("CommandLine") == 0);
        if (bInChoiceDialog)
	    return;   // ignore loss of focus if we're going to the 
	              // choice dialog.
        if (bCommandLine)
	  // don't allow focus to go elsewhere - keep in the text field
	    {
	    javax.swing.Timer timer = new javax.swing.Timer(500,
					  new FocusRequestor(inputField,true));
	    timer.setRepeats(false);
	    timer.start();
            return;
	    }
	DragonPanel parent = getTopLevelPanel();
        if (parent != null)
	    {
	    bDialogVisible = ApplicationManager.isMessageDialogVisible();
	    }
        if (!parent.isVisible())
	    {
            clearField();
	    return;  // don't call validator if cancelled.
	    }
	if ((previousValue != null) && 
            (getFieldValue() != null) &&
            (getFieldValue().equals(previousValue)))
	    {
	    return;
	    }  // only do one focuslost validation for a particular value
	// we do not want to call the validator if there is already
	// an error box up (in this case, the focus off was probably
	// generated by the appearance and focus grab of the modal
	// error dialog).
	if ((validator != null) && (!bDialogVisible)) 
	    {
	    if (!validator.isValid(this))
	        {
		javax.swing.Timer timer = new javax.swing.Timer(200,
					  new FocusRequestor(inputField,
							     false));
		timer.setRepeats(false);
		timer.start();
		previousValue = getFieldValue();
		return;
		}
	    }
	if (callback != null)
	    {
	    callback.executeCallback(this);
	    }
	previousValue = getFieldValue();
	setFieldValue(previousValue);
	}

    public void focusGained(FocusEvent e)
        {
	// put cursor at the end of any current text
	inputField.setCaretPosition(inputField.getText().length());
	}


    //********************************************************************
      /**
       * Override addMouseListener to add to all the subcontrols
       * as well.
       */
    public void addMouseListener(MouseListener listener)
        {
	super.addMouseListener(listener);
	inputField.addMouseListener(listener);
	inputField.putClientProperty(DragonField.PARENT_FIELD,this);
	innerPanel.addMouseListener(listener);
	innerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	outerPanel.addMouseListener(listener);
	outerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	}

      /**
       * Override addKeyListener to add to all the subcontrols
       * as well.
       */
    public void addKeyListener(KeyListener listener)
        {
	inputField.addKeyListener(listener);
	inputField.putClientProperty(DragonField.PARENT_FIELD,this);
	innerPanel.addKeyListener(listener);
	innerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	outerPanel.addKeyListener(listener);
	outerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	}
      
    //********************************************************************
      /** * Get/Set Methods
       */
    public JTextField getInputField() 
        {
        return inputField;
        }
    
    public int getDisplayWidth() 
        {
        return displayWidth;
        }

    public boolean isHorizontal() 
        {
        return bHorizontal;
        }
    
    public void setDisplayWidth(int displayWidth) 
        {
        this.displayWidth = displayWidth;
	inputField.setColumns(displayWidth);
        }
    
    public int getMaxInputChars()
        {
	return maxInputChars;
	}

    public void setMaxInputChars(int maxChars)
        {
        maxInputChars = maxChars;
	FixedLengthDocument doc = 
            (FixedLengthDocument) inputField.getDocument();
	doc.setMaxLength(maxInputChars);
	}

    public boolean returnBlanks() 
        {
        return bReturnBlanks;
        }
    
    public void setReturnBlanks(boolean bFlag) 
        {
        this.bReturnBlanks = bFlag;
        }

    public boolean isInChoiceDialog()
        {
	return bInChoiceDialog;
	}

      /**
       * Method which will create a focus requestor for
       * a field. This is intended to be be called from callback classes.
       * @param delay  How long to wait before transferring focus.
       */
    public void createFocusRequestor(int delay)
         {
	 javax.swing.Timer timer = new javax.swing.Timer(delay,
		  new FocusRequestor(this.inputField,true));
	 timer.setRepeats(false);
	 timer.start();
	 }
 

      //*****************************************************
      /** 
       * Inner class used to issue a delayed focus request when
       * a validation triggered by focusLost fails.*/
    class FocusRequestor implements ActionListener
         {
	 JTextField myField;
	 boolean bReturnFocus = false;

	 /**
	  * Constructor sets myField
	  */
	 public FocusRequestor(JTextField whichField,
			       boolean bReturnFocus)
             {
	     myField = whichField;
	     this.bReturnFocus = bReturnFocus;
	     }

	 /**
	  * Action Listener method
	  */
	 public void actionPerformed(ActionEvent e)
             {
	     if ((validator != null) &&
		 (!getTopLevelPanel().isValidatingAll()) &&
		 (validator.isErrorOutstanding()))
	          {
	          validator.displayLastError();
                  }
	     if (bReturnFocus)
	          {
	          myField.requestFocus();
		  }
	     }
         }

    protected static String cvsInfo = null;
    protected static void setCvsInfo()
        {
        cvsInfo = "\n@(#)  $Id: DTextField.java,v 1.9 2007/01/05 07:41:57 rudahl Exp $ \n";
	}
    }
// End of DTextField.java




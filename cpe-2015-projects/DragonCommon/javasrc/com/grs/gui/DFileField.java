/** 
 * DFileField.java
 *
 * Generated by java-pp.pl from DFileField.java
 * on Mon Jan  8 11:41:02 EST 2001

 * Copyright  2002-2007  Sally Goldin & Kurt Rudahl
 *
 * $Id: DFileField.java,v 1.26 2007/06/19 05:35:28 goldin Exp $
 * $Log: DFileField.java,v $
 * Revision 1.26  2007/06/19 05:35:28  goldin
 * Allow all file fields to accept up to 512 characters
 *
 * Revision 1.25  2007/06/15 11:51:35  goldin
 * Return empty string immediately from getFieldValue if nothing entered
 *
 * Revision 1.24  2007/06/15 11:06:06  goldin
 * Working on path validation issues
 *
 * Revision 1.23  2007/06/15 09:52:13  goldin
 * replace entered path with absolute path
 *
 * Revision 1.22  2007/01/05 07:41:57  rudahl
 * added Whatis info
 *
 * Revision 1.21  2007/01/01 13:52:16  goldin
 * Add and integrate new controls for rule creation screen
 *
 * Revision 1.20  2006/02/11 10:08:20  goldin
 * Fix handling of filenames that include periods
 *
 * Revision 1.19  2005/10/20 09:47:19  goldin
 * Integrate clserror into Dragon
 *
 * Revision 1.18  2005/08/03 04:42:26  goldin
 * Add tracing
 *
 * Revision 1.17  2005/07/24 13:27:04  goldin
 * Fix uppercasing behavior in prep for Linux
 *
 * Revision 1.17  2005/07/13 03:53:33  goldin
 * Fix so that paths don't get upper-cased
 *
 * Revision 1.16  2005/07/04 13:03:35  goldin
 * Upcase memory file names
 *
 * Revision 1.15  2005/03/29 09:12:03  goldin
 * Don't upcase filenames
 *
 * Revision 1.14  2005/02/06 08:08:11  goldin
 * Fix JavaDoc warnings
 *
 * Revision 1.13  2002/10/25 18:04:43  goldin
 * Fix nullptr error
 *
 * Revision 1.12  2002/10/23 21:03:07  goldin
 * Add drive to partial name starting with separator
 *
 * Revision 1.11  2002/09/25 17:22:43  goldin
 * Don't append default path to partial filename before calling file chooser
 *
 * Revision 1.10  2002/09/23 23:00:38  goldin
 * Make beep part of error display  rather than a reaction in the control
 *
 * Revision 1.9  2002/09/23 19:11:44  goldin
 * Infrastructure to suppress file validation when file chooser is coming up
 *
 * Revision 1.8  2002/08/31 00:03:23  goldin
 * continue major redesign of FileChooser
 *
 * Revision 1.7  2002/08/27 20:04:12  goldin
 * convert filechooser to potentially using multiple file types
 *
 * Revision 1.6  2002/06/11 21:21:50  goldin
 * Cosmetic improvments
 *
 * Revision 1.5  2002/05/16 14:41:42  goldin
 * Do completion of any file beginning with '('
 *
 * Revision 1.4  2002/04/02 00:13:28  goldin
 * Put in infrastructure for testing for file overwrite warning flag
 *
 * Revision 1.3  2002/01/02 13:17:28  goldin
 * Fix bug in path data size introduced by changes for installater
 *
 * Revision 1.2  2001/12/18 15:14:54  goldin
 * Allow setting of columns in path controls
 *
 * Revision 1.1  2001/11/30 18:03:09  goldin
 * Moved most of the UI basic components to the com.grs.gui package
 *
 * Revision 1.37  2001/11/16 18:05:54  goldin
 * Move more classes from dragon.ui to gui package
 *
 * Revision 1.36  2001/11/05 13:59:14  goldin
 * Put UI code in a package
 *
 * Revision 1.35  2001/10/31 14:17:05  goldin
 * Don't append extension for *.*
 *
 * Revision 1.34  2001/07/18 15:25:30  goldin
 * Working to fix problems with handling of 'current' color scheme
 *
 * Revision 1.33  2001/07/12 13:14:16  goldin
 * Translate files to uppercase in getFieldValue
 *
 * Revision 1.32  2001/06/29 17:30:16  goldin
 * Implemented handing of state info from reply files
 *
 * Revision 1.31  2001/06/18 12:10:00  goldin
 * Fixing bugs found by Kurt
 *
 * Revision 1.30  2001/06/13 14:12:47  goldin
 * Move buttons to be dialogwide, add ability to have file fields in Qry boxes
 *
 * Revision 1.29  2001/05/10 13:14:51  goldin
 * Continue implementation of SigFile and scaling callbacks
 *
 * Revision 1.28  2001/05/07 12:06:52  goldin
 * Fix bugs in path handling
 *
 * Revision 1.27  2001/04/25 10:51:02  goldin
 * Add function key handling
 *
 * Revision 1.26  2001/04/24 14:14:20  goldin
 * Improve behavior and appearance of file and font choosers
 *
 * Revision 1.25  2001/04/18 15:32:45  goldin
 * Added home directory command line argument
 *
 * Revision 1.24  2001/04/10 11:18:46  goldin
 * Fix problem with modal dialog in FileValidator; extend IntegerValidator
 *
 * Revision 1.23  2001/04/09 14:44:16  goldin
 * Work on file validation. Not complete
 *
 * Revision 1.22  2001/04/09 11:05:42  goldin
 * Add Logging facility logic
 *
 * Revision 1.21  2001/04/06 18:02:54  goldin
 * Fixing bugs
 *
 * Revision 1.20  2001/04/06 09:10:51  goldin
 * Use control label as title for chooser
 *
 * Revision 1.19  2001/04/04 15:24:50  goldin
 * Added partial filename filtering, validation, to file chooser
 *
 * Revision 1.18  2001/04/04 12:16:55  goldin
 * Checkpoint of filechooser work; partial name filtering implemented
 *
 * Revision 1.17  2001/03/26 17:32:08  goldin
 * Further work implementing FileChooser
 *
 * Revision 1.16  2001/03/23 17:01:51  goldin
 * Initial implementation of file chooser
 *
 * Revision 1.15  2001/03/22 12:57:33  goldin
 * Implement paths panel, including initializer, callback, new path datatype
 *
 * Revision 1.14  2001/03/20 18:04:15  goldin
 * Implement tabbed panes, clean up menu help:
 *
 * Revision 1.13  2001/03/16 19:23:46  goldin
 * Added fixed length option for DTextField and DFileField; added callbacks to menu items
 *
 * Revision 1.12  2001/03/03 19:56:58  goldin
 * Fine tuning screen layout and appearance
 *
 * Revision 1.11  2001/02/28 16:24:29  goldin
 * implementing defaults, enhancements to help editor
 *
 * Revision 1.10  2001/02/20 18:39:13  goldin
 * Add callback handling
 *
 * Revision 1.9  2001/02/08 16:14:39  goldin
 * Added HelpEditor capability
 *
 * Revision 1.8  2001/01/29 15:19:32  goldin
 * Continued work on UI
 *
 * Revision 1.7  2001/01/25 20:16:19  goldin
 * Continued work on layout and XML parsing
 *
 * Revision 1.6  2001/01/22 16:14:26  goldin
 * Changes to parse actual generated XML file
 *
 * Revision 1.5  2001/01/17 14:18:23  goldin
 * Actually build initial trial panel from XML document
 *
 * Revision 1.4  2001/01/15 14:20:25  goldin
 * Implement new layout options, makeClone methods
 *
 * Revision 1.3  2001/01/12 19:10:21  goldin
 * Completed implementation of basic control types, added validation and callback support, key handling
 *
 * Revision 1.2  2001/01/09 15:58:55  goldin
 * continued work implementing basic appearance of UI components
 *
 * Revision 1.1  2001/01/08 19:34:42  goldin
 * Initial population for new DRAGON-Java UI
 *
 */

package com.grs.gui;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;

/** Control that allows user to enter file names
*   
* @author  goldin
* @version  Mon Jan 08 11:36:01 EST 2001*/
public class DFileField extends DTextField 
                        implements ActionListener
    {
    protected static final int PATH_MAX = 512;

    protected static final DFileType[] FILETYPE_ALL_ARRAY = {DFileType.ALL}; 

      /**
       * "(Current)" in present language.
       */
    protected static String xlatedCurrent = null;
        
      /** Array of strings such as "=M", "=B", etc.
       *   which represent the memory files allowed for this
       *   file field, in their preferred order.
       */
    protected String[] allowedMemoryFiles = null;
    
      /** Set to true if this field must be filled by the
       *   name of an existing file.
       */
    protected boolean bExisting = false;
    
      /** Set to true if this field must be filled by a path.
       */
    protected boolean bPathData = false;

      /**
       * Set to true if we should warn before overwriting.
       */
    protected boolean bOverwriteWarning = false;

      /**
       * Button to invoke the file dialog.
       */
    protected BrowseButton browseBtn;


      /**
       * Make all file fields the same width.
       */
    protected static int displayWidth = 60;
      /**
       * But paths should be shorter...
       */
    protected static int pathDisplayWidth = 20;


      /**
       * Allow adjustment for paths only.
       */
    protected int actualWidth = 0;

      /**
       * Types of file that should be gotten for this
       * file field. Only element 0 of the array can 
       * have associated memory files (and in general is privileged).
       */
    protected DFileType[] fileTypes = FILETYPE_ALL_ARRAY;

      /**
       * Reference to a class to filter memory files according to state.
       */
    protected MemoryFilter memoryFilter = null;

      /**
       * innerPanel and outerPanel are declared in the
       * parent DTextField class.
       */
      //protected JPanel innerPanel = null;
      //protected JPanel outerPanel = null;
    protected JPanel inputPanel = null;

    //********************************************************************
      /**
       * Constructor creates the UI including
       * the input field and the browse button.
       * Also sets whether the file must previously exist.
       * @param name  Name for new field
       * @param text  Text for label; if null, no label created
       * @param columns Number of columns to display for the text field.
       * @param mustExist If true, the file entered must exist.
       */
    public DFileField(String name, String text, int columns,
		      boolean mustExist, boolean isPathData)
        {
	super(name);
	bFileField = true;
	this.bExisting = mustExist;
	this.bPathData = isPathData;
        this.labelText = text;
	setLayout(new BorderLayout());
	inputPanel = new JPanel(new BorderLayout());
	innerPanel = new JPanel(new BorderLayout());
	outerPanel = new JPanel(new BorderLayout());
	if (text != null)
	    {
	    label = new JLabel(text);
	    innerPanel.add(label,BorderLayout.NORTH);
	    }

        if (bPathData)
	    {
	    if (columns == 0)
	        actualWidth = pathDisplayWidth;
	    else
	        actualWidth = columns;
	    }
	else
	    {
	    actualWidth = displayWidth;
	    }
	inputField = new JTextField(actualWidth);
        maxInputChars = PATH_MAX;
        inputField.setDocument(new FixedLengthDocument(maxInputChars));
	inputField.addFocusListener(this);
	inputField.addKeyListener(this);
	browseBtn = new BrowseButton();
	Dimension fldDim = inputField.getPreferredSize();
	Dimension btnDim = new Dimension(fldDim.height,fldDim.height);
	browseBtn.setPreferredSize(btnDim);
	browseBtn.addActionListener(this);
	browseBtn.addKeyListener(this);
	JPanel innerInputPanel = new JPanel(new BorderLayout());
	innerInputPanel.add(inputField,BorderLayout.NORTH);
	inputPanel.add(innerInputPanel,BorderLayout.CENTER);
	inputPanel.add(browseBtn,BorderLayout.EAST);
	innerPanel.add(inputPanel,BorderLayout.SOUTH);
	outerPanel.add(innerPanel,BorderLayout.NORTH);
	add(outerPanel,BorderLayout.WEST);
	if (xlatedCurrent == null)
	    xlatedCurrent = ApplicationManager.getTextSource().getI18NText(
					   TextKeys.CURRENT,"(Current)");
	}

    //********************************************************************
      /**
       * Create and return copy of the present object. Data items
       * that are set during the addition to a panel are not 
       * copied.
       */
    public DragonField makeClone()
        {
	DFileField clone = new DFileField(name,label.getText(),
					  actualWidth, bExisting,bPathData);
	initializeClone(clone);
        clone.setMaxInputChars(maxInputChars);
        clone.setFileTypes(fileTypes);
	clone.setAllowedMemoryFiles(allowedMemoryFiles);
	clone.setOverwriteWarning(bOverwriteWarning);
	return (DragonField) clone;
	}

    //********************************************************************
      /** Sets the field to be enabled or disabled depending
       *   on the value of the bEnabled argument.
       *   
       * @param  bEnabled Enablement flag
       */
    public void setEnabled(boolean bEnabled) 
        {
	super.setEnabled(bEnabled);
	browseBtn.setEnabled(bEnabled);
        }

      /** Calculates the minimum amount of space (in pixels) required
       * by the field's graphic components. This will usually be
       * based on things like the width of the label in the current font.
       * @return Minimum width of graphical components, in pixels.
       */
    public int calculateWidth()
        {
	int labelWidth = 0;
	int controlWidth = 0;
	if (label != null)
	    {
	    FontMetrics metrics = label.getFontMetrics(label.getFont());
	    labelWidth = metrics.stringWidth(label.getText());
	    }
	controlWidth = inputField.getPreferredSize().width;
	controlWidth += browseBtn.getPreferredSize().width + 5;
	// a bit of extra space for padding between input and button
	return Math.max(labelWidth,controlWidth);
	}

      /** Calculates the minimum amount of vertical space (in pixels) required
       * by the field's graphic components. This will usually be
       * based on things like the width of the label in the current font.
       * @return Minimum height of graphical components, in pixels.
       */
    public int calculateHeight()
        {
	int controlHeight = 0;
	int btnHeight = 0;
	int labelHeight = 0;
	if (label != null)
	    {
	    FontMetrics metrics = label.getFontMetrics(label.getFont());
	    labelHeight = metrics.getHeight() + 
		metrics.getMaxDescent();
	    }
	FontMetrics controlMetrics = 
	   inputField.getFontMetrics(inputField.getFont());
	controlHeight = controlMetrics.getHeight() +
	                controlMetrics.getMaxDescent();
	btnHeight = browseBtn.getPreferredSize().height;
        return labelHeight + (Math.max(controlHeight,btnHeight)) + 4;
	}

      /**
       * Returns true if passed control is equivalent to present
       * control - that is, all values are the same.
       */
    public boolean equivalent(DragonField field)
        {
	if (!(field instanceof DFileField))
	    return false;
	if (!commonFieldsEqual(field))
	    return false;
	DFileField fField = (DFileField) field;
	String[] otherAllowed = fField.getAllowedMemoryFiles();
	if ((otherAllowed == null) && (allowedMemoryFiles != null))
	    return false;
	if ((otherAllowed != null) && (allowedMemoryFiles == null))
	    return false;
	if ((otherAllowed != null) && 
	    (allowedMemoryFiles != null))
	    {
	    if (otherAllowed.length != 
		allowedMemoryFiles.length)
	    return false;
	    for (int i = 0; i < allowedMemoryFiles.length; i++)
	        {
		if (fField.getAllowedMemoryFiles(i).compareTo(allowedMemoryFiles[i])
		    != 0)
		  return false;
	        }
	    }
	if (fField.isExisting() != bExisting)
	    return false;
	if (fField.getDisplayWidth() != displayWidth)
	    return false;
	return true;
	}


    //********************************************************************

      /**
       * Method from the actionListener interface. Called when the
       * browse button is clicked.
       */
    public void actionPerformed(ActionEvent e)
        {
        int option;
	DragonFileChooser chooser;
        bInChoiceDialog = true;
	String partial  = inputField.getText();
        partial = partial.trim();
	if ((partial.length() == 0)||
            (partial.startsWith("=")) ||
	    (partial.startsWith("(")))
	    partial = null;
	// add a default path if none specified

	/*** NO - DON'T DO THIS ****
	if ((partial != null) && (partial.indexOf(File.separator) < 0))
	    {
	    if (bExisting)
	        partial = ApplicationManager.getReadPath() +
		          File.separator + partial;
	    else if (!bPathData) 
	        partial = ApplicationManager.getWritePath() +
		          File.separator + partial;
	    else // no default for paths
	        partial = null;
	    }
	    *****/

	if (bPathData)
	    partial = null;

        if  ((partial != null) &&
             ((partial.startsWith("\\")) || 
              (partial.startsWith("/"))) &&
             (System.getProperty("os.name").startsWith("Win")))
	    {
            String currentDir = System.getProperty("user.dir");
	    partial = currentDir.substring(0,2) +
	                  partial;
	    }
	chooser = selectChooser();
        if (chooser == null)
	    return;
        String currentMemoryFiles[] = null;
        if (memoryFilter != null)
                currentMemoryFiles = memoryFilter.filterAllowedMemoryFiles(
						  allowedMemoryFiles,
						  fileTypes[0]);
	File selected = chooser.chooseFile(fileTypes,currentMemoryFiles,
					   partial,labelText,defaultValue);
	String filename = null;
	if (selected != null)
	    {
	    filename = selected.getAbsolutePath();
	    String simpleFilename = selected.getName();
	    /* check for special char sequences */
	    if ((simpleFilename.startsWith("(")) ||
		(simpleFilename.startsWith("=")))
	        filename = simpleFilename;
	    inputField.setText(filename);
	    }
        inputField.requestFocus();
	bInChoiceDialog = false;
	}

      /**
       * Factorization: returns correct DragonFileChooser based on
       * characteristics of the field.
       */
    public DragonFileChooser selectChooser()
        {
	DragonFileChooser chooser = null;
	if ((bExisting) && (!bPathData))
  	    {
	    chooser = ApplicationManager.getInFileChooser();
	    }
	else if (bPathData)
	    {
	    chooser = ApplicationManager.getPathChooser();
	    }
	else
	    {
	    chooser = ApplicationManager.getOutFileChooser();
	    }
	return chooser;
	}

    //********************************************************************
      /**
       * Override addMouseListener to add to all the subcontrols
       * as well.
       */
    public void addMouseListener(MouseListener listener)
        {
	super.addMouseListener(listener);
	inputField.addMouseListener(listener);
	inputField.putClientProperty(DragonField.PARENT_FIELD,this);
	innerPanel.addMouseListener(listener);
	innerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	outerPanel.addMouseListener(listener);
	outerPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	inputPanel.addMouseListener(listener);
	inputPanel.putClientProperty(DragonField.PARENT_FIELD,this);
	browseBtn.addMouseListener(listener);
	browseBtn.putClientProperty(DragonField.PARENT_FIELD,this);
	}
      /**
       * Override addKeyListener to add to all the subcontrols
       * as well.
       */
    public void addKeyListener(KeyListener listener)
        {
	inputField.addKeyListener(listener);
	innerPanel.addKeyListener(listener);
	outerPanel.addKeyListener(listener);
	inputPanel.addKeyListener(listener);
	browseBtn.addKeyListener(listener);
	}

      /**
       * Override getFieldValue so that it will add a path
       * and an extension if those are not specified, and
       * change all slashes to the appropriate values
       * for the current platform.
       */
    public String getFieldValue()
        {
	String valueString = null;
	String rawString  = inputField.getText();
        rawString = rawString.trim();
        rawString = rawString.replace('\\',File.separatorChar);
        rawString = rawString.replace('/',File.separatorChar);
        if (rawString.length() == 0)
             return rawString; 
	if ((!bPathData) &&
	    (rawString.length() != 0) &&
            (!rawString.startsWith("=")) &&
	    (!rawString.startsWith("(")))
	    {
            valueString = rawString;
	    if (rawString.indexOf(File.separator) < 0)
	        {
	        if (bExisting)
	            valueString = ApplicationManager.getReadPath() +
		          File.separator + valueString;
	        else if (!bPathData) 
	            valueString = ApplicationManager.getWritePath() +
		          File.separator + valueString;
	        }
            /* find extension for this file type */
	    String extension = null;
            if ((fileTypes != null) &&
		(fileTypes.length >= 1) && 
		(fileTypes[0] != DFileType.ALL) &&
		(fileTypes[0] != DFileType.PATH))
	        {
                extension = fileTypes[0].getFilePattern();
	        int p = extension.indexOf(";");
	        if (p >= 0)
	            extension = extension.substring(0,p);
		}
	    int pos = rawString.lastIndexOf(".");
            if ((pos < 0) && (extension != null))
	        {
		valueString = valueString + extension;
		}
            else if (extension != null)
	        {
                String chkExtension = rawString.substring(pos);
		if (chkExtension.toUpperCase().compareTo(extension.toUpperCase()) != 0)
		     valueString = valueString + extension;	  
	        }
	    }
	else if (rawString.startsWith("("))
	    {
	    valueString = xlatedCurrent;
            }
	else if (rawString.startsWith("="))
	    {
	    /* upcase =M and so on */
	    valueString = rawString.toUpperCase();
	    }
	else // this should occur only for paths
	    {
	    File pathFile = new File(rawString); 
	    valueString = pathFile.getAbsolutePath();
	    }

	/* 3/29/05 don't upper case unconditionally
	   because this messes up Linux */
	return valueString;
	}

      /**
       * Method to show choices or choice dialog. Overridden by
       * so that it displays the file browsing window.
       */
    public void showChoices()
        {
	bInChoiceDialog = true;
        browseBtn.doClick();
	}



    //********************************************************************
      /** * Get/Set Methods
       */
    public String[] getAllowedMemoryFiles() 
        {
        return allowedMemoryFiles;
        }
    
    public String getAllowedMemoryFiles(int index) 
        {
        return allowedMemoryFiles[index];
        }
    
    public void setAllowedMemoryFiles(String[] allowedMemoryFiles) 
        {
        this.allowedMemoryFiles = allowedMemoryFiles;
        }
    
    public void setAllowedMemoryFiles(int index, String allowedMemoryFiles) 
        {
        this.allowedMemoryFiles[index] = allowedMemoryFiles;
        }
    
    public boolean isExisting() 
        {
        return bExisting;
        }
    
    public void setExisting(boolean bExisting) 
        {
        this.bExisting = bExisting;
        }

    public boolean getOverwriteWarning() 
        {
        return bOverwriteWarning;
        }
    
    public void setOverwriteWarning(boolean bFlag) 
        {
        this.bOverwriteWarning = bFlag;
        }

    public boolean isPathData() 
        {
        return bPathData;
        }
    
    public void setPathData(boolean bPathData) 
        {
        this.bPathData = bPathData;
        }

    public DFileType[] getFileTypes() 
        {
        return fileTypes;
        }
      

      /**
       * To ease conversion - get the first element in the
       * filetypes array.
       */
    public DFileType getFileType() 
        {
        return fileTypes[0];
        }
    
    public void setFileTypes(DFileType[] types) 
        {
	if (types != null)
            this.fileTypes = types;
	else
	    {
	    this.fileTypes = FILETYPE_ALL_ARRAY;
	    }
	}
    
    public void setMemoryFilter(MemoryFilter filter)
        {
	memoryFilter = filter;
	}

      /**
       * Override setFileField to be a null method.
       * This subclass is always a file field.
       */
    public void setFileField(boolean bFlag)
        {
	}

    public int getMaxInputChars()
        {
	return maxInputChars;
	}

	/* Don't allow the max to be decreased */
    public void setMaxInputChars(int maxChars)
        {
	if (maxChars > maxInputChars)
	    { 
            maxInputChars = maxChars;
	    FixedLengthDocument doc = 
              (FixedLengthDocument) inputField.getDocument();
	    doc.setMaxLength(maxInputChars);
            }
	}

    public int getActualWidth()
        {
        return actualWidth;
	}

    public void setActualWidth(int newWidth)
        {
	actualWidth = newWidth;
	inputField.setColumns(actualWidth);
	setSize(calculateWidth(),calculateHeight());
	}

    protected static String cvsInfo = null;
    protected static void setCvsInfo()
        {
        cvsInfo = "\n@(#)  $Id: DFileField.java,v 1.26 2007/06/19 05:35:28 goldin Exp $ \n";
	}
    } 

// End of DFileField.java



